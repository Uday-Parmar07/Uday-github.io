<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>I Built Google Bigtable in Go: One File, Zero Dependencies | Uday Parmar</title>
<meta name="keywords" content="golang, paper implementation">
<meta name="description" content="Recently, I read the the Google Bigtable paper, and what a fun read it was.
And I asked myself, how much of it can I fit in a single go file, with no external dependencies whatsoever, and it turns out, quite a lot. And that&rsquo;s what this blog post is about. My implementation of this famous paper.
      

    üåê
    
        You can find the source code of this project in this github repository
    



1. What Is Bigtable?

">
<meta name="author" content="map[name:Uday]">
<link rel="canonical" href="http://localhost:1313/archive/old_posts/implementing-google-bigtable-in-golang/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e4ab7bca89e92a434b6ee0659c4052124b24f15cc9bbfa80e5b5201587388aba.css" integrity="sha256-5Kt7yonpKkNLbuBlnEBSEksk8VzJu/qA5bUgFYc4iro=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/archive/old_posts/implementing-google-bigtable-in-golang/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.min.js"></script>
<script>
  
  mermaid.initialize({
    startOnLoad: true,
    theme: "dark",
    themeVariables: {
      darkMode: true,
      background: "#000000",
      primaryColor: "#FFFFFF",
      lineColor: "#FFFFFF",
      textColor: "#FFFFFF",
      nodeTextColor: "#FFFFFF",
      tertiaryColor: "#CCCCCC",
    },
    
    sequence: {
      showSequenceNumbers: true,
    },
    flowchart: {
      htmlLabels: true,
      curve: "basis",
    },
  });
</script>


</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Uday Parmar (Alt + H)">Uday Parmar</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/musings/" title="Essays">
                    <span>Essays</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="üîç (Alt &#43; /)" accesskey=/>
                    <span>üîç</span>
                </a>
            </li>
        </ul>
    </nav>
    
    
</header>
<main class="main">
<article class="post-single">
    <header class="post-header">
        
        <h1 class="post-title entry-hint-parent">
            I Built Google Bigtable in Go: One File, Zero Dependencies
        </h1>
        <div class="post-meta"><span title='2026-02-20 19:37:55 +0530 IST'>February 20, 2026</span>&nbsp;¬∑&nbsp;33 min&nbsp;¬∑&nbsp;map[name:Uday]

</div>
    </header> 
<figure class="entry-cover"><a href="http://localhost:1313/images/bigtable.png" target="_blank"
            rel="noopener noreferrer"><img loading="eager" src="http://localhost:1313/images/bigtable.png" alt=""></a>
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#1-what-is-bigtable" aria-label="1. What Is Bigtable?">1. What Is Bigtable?</a><ul>
                        
                <li>
                    <a href="#but-what-was-the-need-of-bigtable" aria-label="But what was the need of BigTable?">But what was the need of BigTable?</a></li></ul>
                </li>
                <li>
                    <a href="#2-constants-and-configuration" aria-label="2. Constants and Configuration">2. Constants and Configuration</a></li>
                <li>
                    <a href="#3-core-data-types" aria-label="3. Core Data Types">3. Core Data Types</a><ul>
                        
                <li>
                    <a href="#timestamp" aria-label="Timestamp">Timestamp</a></li>
                <li>
                    <a href="#rowkey" aria-label="RowKey">RowKey</a></li>
                <li>
                    <a href="#column-and-columnfamily" aria-label="Column and ColumnFamily">Column and ColumnFamily</a></li>
                <li>
                    <a href="#cell" aria-label="Cell">Cell</a></li>
                <li>
                    <a href="#cellkey-and-comparecellkeys" aria-label="CellKey and CompareCellKeys">CellKey and CompareCellKeys</a></li>
                <li>
                    <a href="#mutation" aria-label="Mutation">Mutation</a></li>
                <li>
                    <a href="#rowrange" aria-label="RowRange">RowRange</a></li></ul>
                </li>
                <li>
                    <a href="#4-schema" aria-label="4. Schema">4. Schema</a></li>
                <li>
                    <a href="#5-gfs--the-storage-foundation" aria-label="5. GFS : The Storage Foundation">5. GFS : The Storage Foundation</a></li>
                <li>
                    <a href="#6-chubby-the-lock-service" aria-label="6. Chubby: The Lock Service">6. Chubby: The Lock Service</a><ul>
                        
                <li>
                    <a href="#sessions-and-leases" aria-label="Sessions and Leases">Sessions and Leases</a></li>
                <li>
                    <a href="#locks" aria-label="Locks">Locks</a></li>
                <li>
                    <a href="#watches" aria-label="Watches">Watches</a></li>
                <li>
                    <a href="#pre-created-paths" aria-label="Pre-created Paths">Pre-created Paths</a></li></ul>
                </li>
                <li>
                    <a href="#7-bloom-filter" aria-label="7. Bloom Filter">7. Bloom Filter</a></li>
                <li>
                    <a href="#8-memtable-the-in-memory-write-buffer" aria-label="8. Memtable: The In-Memory Write Buffer">8. Memtable: The In-Memory Write Buffer</a><ul>
                        
                <li>
                    <a href="#sorted-insertion" aria-label="Sorted Insertion">Sorted Insertion</a></li>
                <li>
                    <a href="#get-and-scan" aria-label="Get and Scan">Get and Scan</a></li>
                <li>
                    <a href="#freeze" aria-label="Freeze">Freeze</a></li>
                <li>
                    <a href="#iterator" aria-label="Iterator">Iterator</a></li></ul>
                </li>
                <li>
                    <a href="#9-commit-log-the-write-ahead-log" aria-label="9. Commit Log: The Write-Ahead Log">9. Commit Log: The Write-Ahead Log</a><ul>
                        
                <li>
                    <a href="#one-log-per-server-not-per-tablet" aria-label="One Log Per Server (Not Per Tablet)">One Log Per Server (Not Per Tablet)</a></li>
                <li>
                    <a href="#recovery" aria-label="Recovery">Recovery</a></li></ul>
                </li>
                <li>
                    <a href="#10-sstable-immutable-on-disk-storage" aria-label="10. SSTable: Immutable On-Disk Storage">10. SSTable: Immutable On-Disk Storage</a><ul>
                        
                <li>
                    <a href="#file-format" aria-label="File Format">File Format</a></li>
                <li>
                    <a href="#sstablewriter" aria-label="SSTableWriter">SSTableWriter</a></li>
                <li>
                    <a href="#sstablereader" aria-label="SSTableReader">SSTableReader</a></li></ul>
                </li>
                <li>
                    <a href="#11-tablet-a-contiguous-row-range" aria-label="11. Tablet: A Contiguous Row Range">11. Tablet: A Contiguous Row Range</a><ul>
                        
                <li>
                    <a href="#the-merged-read-view" aria-label="The Merged Read View">The Merged Read View</a></li>
                <li>
                    <a href="#mergecells" aria-label="mergeCells">mergeCells</a></li>
                <li>
                    <a href="#minor-compaction" aria-label="Minor Compaction">Minor Compaction</a></li>
                <li>
                    <a href="#major-compaction" aria-label="Major Compaction">Major Compaction</a></li>
                <li>
                    <a href="#tablet-split" aria-label="Tablet Split">Tablet Split</a></li>
                <li>
                    <a href="#tablet-states" aria-label="Tablet States">Tablet States</a></li></ul>
                </li>
                <li>
                    <a href="#12-caches-block-cache-and-scan-cache" aria-label="12. Caches: Block Cache and Scan Cache">12. Caches: Block Cache and Scan Cache</a><ul>
                        
                <li>
                    <a href="#block-cache" aria-label="Block Cache">Block Cache</a></li>
                <li>
                    <a href="#scan-cache" aria-label="Scan Cache">Scan Cache</a></li></ul>
                </li>
                <li>
                    <a href="#13-tablet-server" aria-label="13. Tablet Server">13. Tablet Server</a><ul>
                        
                <li>
                    <a href="#startup-and-liveness" aria-label="Startup and Liveness">Startup and Liveness</a></li>
                <li>
                    <a href="#background-goroutines" aria-label="Background Goroutines">Background Goroutines</a></li>
                <li>
                    <a href="#the-write-path" aria-label="The Write Path">The Write Path</a></li>
                <li>
                    <a href="#the-read-path" aria-label="The Read Path">The Read Path</a></li>
                <li>
                    <a href="#atomic-read-modify-write" aria-label="Atomic Read-Modify-Write">Atomic Read-Modify-Write</a></li></ul>
                </li>
                <li>
                    <a href="#14-master-server" aria-label="14. Master Server">14. Master Server</a><ul>
                        
                <li>
                    <a href="#master-election" aria-label="Master Election">Master Election</a></li>
                <li>
                    <a href="#server-monitoring" aria-label="Server Monitoring">Server Monitoring</a></li>
                <li>
                    <a href="#tablet-assignment" aria-label="Tablet Assignment">Tablet Assignment</a></li>
                <li>
                    <a href="#load-balancing" aria-label="Load Balancing">Load Balancing</a></li>
                <li>
                    <a href="#table-creation" aria-label="Table Creation">Table Creation</a></li></ul>
                </li>
                <li>
                    <a href="#15-tablet-location-hierarchy" aria-label="15. Tablet Location Hierarchy">15. Tablet Location Hierarchy</a></li>
                <li>
                    <a href="#16-client-library" aria-label="16. Client Library">16. Client Library</a><ul>
                        
                <li>
                    <a href="#put-get-delete" aria-label="Put, Get, Delete">Put, Get, Delete</a></li>
                <li>
                    <a href="#getversions" aria-label="GetVersions">GetVersions</a></li>
                <li>
                    <a href="#scan" aria-label="Scan">Scan</a></li>
                <li>
                    <a href="#batchwrite" aria-label="BatchWrite">BatchWrite</a></li>
                <li>
                    <a href="#increment-and-append" aria-label="Increment and Append">Increment and Append</a></li></ul>
                </li>
                <li>
                    <a href="#17-cluster-bootstrap" aria-label="17. Cluster Bootstrap">17. Cluster Bootstrap</a></li></ul>
                    
                <li>
                    <a href="#18-the-demo" aria-label="18. The Demo">18. The Demo</a><ul>
                        
                <li>
                    <a href="#step-12-cluster-boot-and-table-creation" aria-label="Step 1‚Äì2: Cluster Boot and Table Creation">Step 1‚Äì2: Cluster Boot and Table Creation</a></li>
                <li>
                    <a href="#step-34-writes-and-reads" aria-label="Step 3‚Äì4: Writes and Reads">Step 3‚Äì4: Writes and Reads</a></li>
                <li>
                    <a href="#step-5-multi-version-reads" aria-label="Step 5: Multi-Version Reads">Step 5: Multi-Version Reads</a></li>
                <li>
                    <a href="#step-6-range-scan" aria-label="Step 6: Range Scan">Step 6: Range Scan</a></li>
                <li>
                    <a href="#step-78-atomic-counter-and-append" aria-label="Step 7‚Äì8: Atomic Counter and Append">Step 7‚Äì8: Atomic Counter and Append</a></li>
                <li>
                    <a href="#step-9-deletion" aria-label="Step 9: Deletion">Step 9: Deletion</a></li>
                <li>
                    <a href="#step-10-compaction-under-load" aria-label="Step 10: Compaction Under Load">Step 10: Compaction Under Load</a></li>
                <li>
                    <a href="#step-11-batch-write" aria-label="Step 11: Batch Write">Step 11: Batch Write</a></li>
                <li>
                    <a href="#19-data-flow-summary" aria-label="19. Data Flow Summary">19. Data Flow Summary</a><ul>
                        
                <li>
                    <a href="#how-the-write-operates" aria-label="How the write operates">How the write operates</a></li>
                <li>
                    <a href="#and-a-read" aria-label="And a read:">And a read:</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

    <div class="post-content"><p>Recently, I read the the <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">Google Bigtable paper</a>, and what a fun read it was.</p>
<p>And I asked myself, how much of it can I fit in a single go file, with no external dependencies whatsoever, and it turns out, quite a lot. And that&rsquo;s what this blog post is about. My implementation of this famous paper.</p>
      
<div class="callout callout-default">
    <div class="callout-emoji"><div class="emoji">üåê</div></div>
    <div class="callout-content">
        <div class="callout-text">You can find the source code of this project in this <a href="https://github.com/Jitesh117/bigtableGo"><strong>github repository</strong></a></div>
    </div>
</div>
<style>
   
  .callout {
    overflow-x: auto;
    margin: 1.5rem 0;
    display: flex;
    border-left: 4px solid;
    border-radius: 0.75rem;
    background-color: #f9fafb;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    padding: 1rem;
    align-items: flex-start;
  }

  [dir="rtl"] .callout {
    padding: 0.5rem 0 0.5rem 1rem;
  }

   
  .callout-emoji {
    padding-left: 0.75rem;
    padding-right: 0.5rem;
  }

  [dir="rtl"] .callout-emoji {
    padding-right: 0.75rem;
    padding-left: 0.5rem;
  }

   
  .emoji {
    user-select: none;
    font-size: 1.25rem;
    font-family: "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  }

   
  .icon-inline {
    display: inline-block;
    vertical-align: middle;
    height: 1.2em;
  }

   
  .callout-content {
    width: 100%;
    min-width: 0;
    line-height: 1.75;
  }

   
  .callout-text {
    margin-top: 1.5rem;
    line-height: 1.75;
  }

  .callout-text:first-child {
    margin-top: 0;
  }

  .callout-default {
    border-color: rgba(251, 146, 60, 0.3);
    background-color: rgba(251, 146, 60, 0.2);
    color: rgb(253, 186, 116);
  }

  .callout-info {
    border-color: #6b4c3b;
    background-color: rgba(251, 146, 60, 0.2);
    color: rgb(191, 219, 254);
  }

  .callout-warning {
    border-color: rgba(253, 224, 71, 0.3);
    background-color: rgba(161, 98, 7, 0.3);
    color: rgb(253, 224, 71);
  }

  .callout-error {
    border-color: rgba(254, 202, 202, 0.3);
    background-color: rgba(153, 27, 27, 0.3);
    color: rgb(254, 202, 202);
  }
</style>

<h2 id="1-what-is-bigtable">1. What Is Bigtable?<a hidden class="anchor" aria-hidden="true" href="#1-what-is-bigtable">#</a></h2>
<p><img loading="lazy" src="/images/bigtable_arch.png" alt="Architecture"  />
</p>
<p>Bigtable is a distributed storage system designed to scale to petabytes of data across thousands of commodity servers. Despite being called a &ldquo;table,&rdquo; it is not a relational database.</p>
<p>I mean sure it does resemble a database, but it does something different, and it does it really well. It provides clients with a simple data model that supports dynamiccontrol over data layout and format, and allow clients to reason about the locality properties of the data represented in the underlying storage.</p>
<p>It is a <strong>sparse, distributed, persistent, multidimensional sorted map</strong>. Very big words right? Don&rsquo;t be intimidated. It basically means you have sorted dictionary(I&rsquo;m assuming you&rsquo;re familiar with python a bit) as your primary data structure.</p>
<p>If this still seems daunting to look at, if translated to golang, this is how it would look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">RowKey</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">)</span><span class="w"> </span><span class="nf">String</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">)</span><span class="w"> </span><span class="nf">Compare</span><span class="p">(</span><span class="nx">other</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">other</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Column</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nx">Family</span><span class="w">    </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nx">Qualifier</span><span class="w"> </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="nx">Column</span><span class="p">)</span><span class="w"> </span><span class="nf">String</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">Family</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;:&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">Qualifier</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is the &#34;big&#34; table</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Cell</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nx">Row</span><span class="w">       </span><span class="nx">RowKey</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nx">Col</span><span class="w">       </span><span class="nx">Column</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nx">Timestamp</span><span class="w"> </span><span class="nx">Timestamp</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nx">Value</span><span class="w">     </span><span class="p">[]</span><span class="kt">byte</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nx">Deleted</span><span class="w">   </span><span class="kt">bool</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="but-what-was-the-need-of-bigtable">But what was the need of BigTable?<a hidden class="anchor" aria-hidden="true" href="#but-what-was-the-need-of-bigtable">#</a></h3>
<p>When data you have to store gets to a humongous size, you need certain things in check:</p>
<ol>
<li>Wide applicability</li>
<li>Scalability</li>
<li>High Performance(of course)</li>
<li>High availability!!!</li>
</ol>
<p>BigTable solved for these problems, BigTable was used for a variety of workloads, from latency sensitive data serving to heavy throughput batch processing.
Every piece of data is indexed by three coordinates:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(row key, column key, timestamp) ‚Üí value
</span></span></code></pre></div><ul>
<li><strong>Row keys</strong> are arbitrary byte strings, sorted lexicographically. All reads and writes to a single row are atomic.</li>
<li><strong>Column keys</strong> are grouped into <strong>column families</strong> (e.g., <code>anchor</code>, <code>contents</code>). Within a family, column qualifiers can be anything.</li>
<li><strong>Timestamps</strong> allow multiple versions of a value to coexist. The system can be configured to keep the latest N versions or all versions within a time window.</li>
</ul>
<p>The data model gives users enormous flexibility. Google&rsquo;s original use cases included the web index (storing crawled HTML with timestamps), Google Analytics, Google Earth, and Gmail.</p>
<p>Pretty simple right? Now let&rsquo;s discuss what do each field in the <code>Cell</code> struct actually mean.</p>
<h2 id="2-constants-and-configuration">2. Constants and Configuration<a hidden class="anchor" aria-hidden="true" href="#2-constants-and-configuration">#</a></h2>
<p>Before we get into the fun stuff, let&rsquo;s talk about the boring-but-important numbers that control how the whole system behaves. Think of these as the dials you&rsquo;d turn if you were deploying this in production.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">DefaultMemtableMaxSize</span><span class="w">          </span><span class="p">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">DefaultMajorCompactionThreshold</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">5</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">MetadataTableName</span><span class="w">               </span><span class="p">=</span><span class="w"> </span><span class="s">&#34;METADATA&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">MaxTabletsPerServer</span><span class="w">             </span><span class="p">=</span><span class="w"> </span><span class="mi">1000</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">ChubbyLeaseDuration</span><span class="w">             </span><span class="p">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><strong><code>DefaultMemtableMaxSize</code></strong> (4 MB): Once an in-memory write buffer (the memtable) reaches this size, it is frozen and flushed to disk as an SSTable. In production Bigtable this is configurable per table.</li>
<li><strong><code>DefaultMajorCompactionThreshold</code></strong> (5): After 5 SSTables accumulate for a tablet, a major compaction is triggered to merge them into one, reclaiming space from deleted data.</li>
<li><strong><code>MetadataTableName</code></strong>: The special internal <code>METADATA</code> table stores the locations of all user tablets. It is managed by Bigtable itself, not by users.</li>
<li><strong><code>MaxTabletsPerServer</code></strong> (1000): A safety cap on how many tablets one server can hold. Real servers handle tablet counts based on memory and I/O capacity.</li>
<li><strong><code>ChubbyLeaseDuration</code></strong> (10s): How long a Chubby session remains valid between heartbeats. If a tablet server fails to renew within this window, the master declares it dead.</li>
<li><strong><code>LatestTimestamp</code></strong>: A sentinel value (<code>MaxInt64</code>) used when searching for the newest version of a cell. By sorting timestamps in descending order, the newest version always comes first.</li>
</ul>
<h2 id="3-core-data-types">3. Core Data Types<a hidden class="anchor" aria-hidden="true" href="#3-core-data-types">#</a></h2>
<p>This section defines the fundamental vocabulary of the system, the building blocks every other component uses.</p>
<h3 id="timestamp">Timestamp<a hidden class="anchor" aria-hidden="true" href="#timestamp">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Timestamp</span><span class="w"> </span><span class="kt">int64</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="nf">Now</span><span class="p">()</span><span class="w"> </span><span class="nx">Timestamp</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nf">Timestamp</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixMicro</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Timestamps are microsecond-precision Unix timestamps stored as <code>int64</code>. The paper states that clients can assign their own timestamps for controlled versioning, or let Bigtable assign them automatically. <code>Now()</code> is the automatic assignment path.</p>
<h3 id="rowkey">RowKey<a hidden class="anchor" aria-hidden="true" href="#rowkey">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">RowKey</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">r</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">)</span><span class="w"> </span><span class="nf">Compare</span><span class="p">(</span><span class="nx">other</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">other</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Row keys are raw byte slices. The entire Bigtable data model hinges on <strong>lexicographic ordering</strong> of row keys, this is what makes range scans efficient. A famous design pattern from the paper is reversing domain names (<code>com.google</code> instead of <code>google.com</code>) so that pages from the same domain cluster together on disk.</p>
<h3 id="column-and-columnfamily">Column and ColumnFamily<a hidden class="anchor" aria-hidden="true" href="#column-and-columnfamily">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Column</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Family</span><span class="w">    </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Qualifier</span><span class="w"> </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>A column is identified by two parts separated by a colon: <code>family:qualifier</code>. The family (<code>anchor</code>, <code>contents</code>, <code>language</code>) is defined at table-creation time and controls compression, versioning policy, and memory residency. The qualifier is dynamic, it can be anything and is not declared in advance. This is what makes Bigtable &ldquo;sparse&rdquo;: a row only stores the columns it actually has values for.</p>
<h3 id="cell">Cell<a hidden class="anchor" aria-hidden="true" href="#cell">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Cell</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Row</span><span class="w">       </span><span class="nx">RowKey</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Col</span><span class="w">       </span><span class="nx">Column</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Timestamp</span><span class="w"> </span><span class="nx">Timestamp</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Value</span><span class="w">     </span><span class="p">[]</span><span class="kt">byte</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Deleted</span><span class="w">   </span><span class="kt">bool</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>A <code>Cell</code> is one versioned value at a specific <code>(row, column, timestamp)</code> coordinate. The <code>Deleted</code> flag makes it a <strong>tombstone</strong> , a marker that says &ldquo;this cell was deleted.&rdquo; Tombstones are how deletions propagate through the system before a major compaction permanently removes the data.</p>
<h3 id="cellkey-and-comparecellkeys">CellKey and CompareCellKeys<a hidden class="anchor" aria-hidden="true" href="#cellkey-and-comparecellkeys">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">CellKey</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Row</span><span class="p">,</span><span class="w"> </span><span class="nx">Family</span><span class="p">,</span><span class="w"> </span><span class="nx">Qualifier</span><span class="w"> </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Timestamp</span><span class="w">              </span><span class="nx">Timestamp</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="nf">CompareCellKeys</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="nx">CellKey</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// row asc ‚Üí family asc ‚Üí qualifier asc ‚Üí timestamp desc</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>CellKey</code> is the sort key used throughout the system, in the memtable, in SSTables, and during merge operations. The critical detail is that <strong>timestamps are sorted descending</strong>: newest versions come first. This means a simple forward scan naturally yields the most recent version first, which is what most reads want.</p>
<h3 id="mutation">Mutation<a hidden class="anchor" aria-hidden="true" href="#mutation">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Mutation</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Type</span><span class="w">      </span><span class="nx">MutationType</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Col</span><span class="w">       </span><span class="nx">Column</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Timestamp</span><span class="w"> </span><span class="nx">Timestamp</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Value</span><span class="w">     </span><span class="p">[]</span><span class="kt">byte</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Mutations represent write operations. There are four types: <code>MutationSet</code> (write a value), <code>MutationDelete</code> (delete a cell), <code>MutationDeleteRow</code> (delete all cells in a row), and <code>MutationDeleteFamily</code> (delete all cells in a column family). Per-row atomicity means all mutations in one <code>Write()</code> call either all succeed or all fail.</p>
<h3 id="rowrange">RowRange<a hidden class="anchor" aria-hidden="true" href="#rowrange">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">RowRange</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Start</span><span class="w"> </span><span class="nx">RowKey</span><span class="w"> </span><span class="c1">// inclusive</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">End</span><span class="w">   </span><span class="nx">RowKey</span><span class="w"> </span><span class="c1">// exclusive; nil means unbounded</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>RowRange</code> defines a half-open interval <code>[Start, End)</code> over row keys. This is the unit of work for scans. <code>nil</code> endpoints represent unbounded ranges, meaning &ldquo;start of table&rdquo; or &ldquo;end of table.&rdquo; Tablets are also described by <code>RowRange</code>s , a tablet server only accepts reads and writes for row keys within its assigned range.</p>
<h2 id="4-schema">4. Schema<a hidden class="anchor" aria-hidden="true" href="#4-schema">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">TableSchema</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Name</span><span class="w">           </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">ColumnFamilies</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">ColumnFamily</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>A <code>TableSchema</code> is the schema object created when a user calls <code>CreateTable</code>. In Bigtable, schema changes are lightweight, you can add or remove column families without touching the data. The <code>ColumnFamily</code> struct stores per-family tuning parameters:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">ColumnFamily</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Name</span><span class="w">        </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">MaxVersions</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">TTL</span><span class="w">         </span><span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Compression</span><span class="w"> </span><span class="kt">string</span><span class="w">   </span><span class="c1">// &#34;none&#34;, &#34;snappy&#34;, &#34;zlib&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">BloomFilter</span><span class="w"> </span><span class="kt">bool</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">InMemory</span><span class="w">    </span><span class="kt">bool</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><strong><code>MaxVersions</code></strong>: How many historical versions to keep. Once the limit is exceeded, old versions are garbage-collected during compaction.</li>
<li><strong><code>TTL</code></strong>: Time-to-live. Versions older than this duration are automatically deleted during compaction.</li>
<li><strong><code>Compression</code></strong>: SSTables for this family will be compressed using the named algorithm. Compression is per-family because some data (like HTML) compresses well while other data (like encrypted blobs) does not.</li>
<li><strong><code>InMemory</code></strong>: If true, all SSTables for this column family are kept in memory for faster reads. The paper uses this for the <code>METADATA</code> table&rsquo;s location columns.</li>
</ul>
<p><code>AddColumnFamily</code> enforces uniqueness and sets default values. <code>GetColumnFamily</code> uses a read lock for concurrent access.</p>
<h2 id="5-gfs--the-storage-foundation">5. GFS : The Storage Foundation<a hidden class="anchor" aria-hidden="true" href="#5-gfs--the-storage-foundation">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">GFS</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">baseDir</span><span class="w"> </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">mu</span><span class="w">      </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">files</span><span class="w">   </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">GFSFile</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>In the real Bigtable, the Google File System (GFS) provides a reliable, replicated, distributed file system. GFS handles replication, fault tolerance, and large sequential I/O. Our implementation simulates GFS using the local filesystem under <code>/tmp/bigtable_gfs</code>.</p>
<p>The <code>GFS</code> struct tracks a registry of open files and delegates to standard <code>os</code> package operations. The key methods are:</p>
<ul>
<li><strong><code>Create(name)</code></strong>: Creates a new file, ensuring all parent directories exist.</li>
<li><strong><code>Append(name, data)</code></strong>: Opens the file in append mode and writes bytes atomically. This is the primary write pattern for the commit log.</li>
<li><strong><code>Read(name)</code></strong>: Returns the entire file contents. In real GFS, reads can be streamed in chunks.</li>
<li><strong><code>Write(name, data)</code></strong>: Atomically replaces a file&rsquo;s content. This is used for SSTable creation: write the whole file at once, then make it visible.</li>
<li><strong><code>Register(name)</code></strong>: Registers a file that already exists on disk (used during recovery).</li>
</ul>
<p>The design of GFS is central to Bigtable&rsquo;s architecture. Because GFS replicates data across machines, Bigtable does not need to implement its own replication. SSTables are immutable once written, which makes them trivially replicable and cacheable.</p>
<h2 id="6-chubby-the-lock-service">6. Chubby: The Lock Service<a hidden class="anchor" aria-hidden="true" href="#6-chubby-the-lock-service">#</a></h2>
<p>Chubby is a distributed lock service that Bigtable relies on for five critical functions:</p>
<ol>
<li><strong>Master election</strong>: Only one master can hold the master lock at a time.</li>
<li><strong>Tablet server liveness</strong>: Each tablet server holds a lock; if the lock is lost, the master knows the server is dead.</li>
<li><strong>Root tablet location</strong>: Chubby stores the address of the root tablet, which is the entry point for the tablet location hierarchy.</li>
<li><strong>ACLs</strong>: Access control lists are stored as Chubby files.</li>
<li><strong>Schema bootstrap</strong>: The existence of a Bigtable cluster is anchored in a Chubby directory.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Chubby</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">nodes</span><span class="w">    </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">ChubbyNode</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">sessions</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">ChubbySession</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">ChubbyNode</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Path</span><span class="w">     </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Content</span><span class="w">  </span><span class="p">[]</span><span class="kt">byte</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Lock</span><span class="w">     </span><span class="kt">string</span><span class="w"> </span><span class="c1">// session ID holding the lock</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Watchers</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">chan</span><span class="w"> </span><span class="kd">struct</span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="sessions-and-leases">Sessions and Leases<a hidden class="anchor" aria-hidden="true" href="#sessions-and-leases">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">ChubbySession</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">id</span><span class="w">       </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">leaseExp</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Every participant (master, each tablet server, each client) opens a Chubby session. Sessions have leases that must be periodically renewed via <code>RenewLease()</code>. If a lease expires, the session becomes invalid, any locks held by that session are released, and watchers are notified. This is how Bigtable detects server failures without an explicit heartbeat protocol.</p>
<h3 id="locks">Locks<a hidden class="anchor" aria-hidden="true" href="#locks">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Chubby</span><span class="p">)</span><span class="w"> </span><span class="nf">TryLock</span><span class="p">(</span><span class="nx">path</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">sess</span><span class="w"> </span><span class="o">*</span><span class="nx">ChubbySession</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">Lock</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#34;&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">node</span><span class="p">.</span><span class="nx">Lock</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">sess</span><span class="p">.</span><span class="nx">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">node</span><span class="p">.</span><span class="nx">Lock</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">sess</span><span class="p">.</span><span class="nx">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Locks are exclusive. <code>TryLock</code> is non-blocking: it returns <code>true</code> if the lock was acquired, <code>false</code> if another session holds it. This is what the master uses for election: whichever process wins the lock first becomes the active master.</p>
<h3 id="watches">Watches<a hidden class="anchor" aria-hidden="true" href="#watches">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Chubby</span><span class="p">)</span><span class="w"> </span><span class="nf">Watch</span><span class="p">(</span><span class="nx">path</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">sess</span><span class="w"> </span><span class="o">*</span><span class="nx">ChubbySession</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="kd">struct</span><span class="p">{},</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>Watches provide event notification. A watcher is notified when a node&rsquo;s content changes or its lock is released. The master uses watches to detect when a tablet server&rsquo;s lock node disappears (server died) and to monitor configuration changes.</p>
<h3 id="pre-created-paths">Pre-created Paths<a hidden class="anchor" aria-hidden="true" href="#pre-created-paths">#</a></h3>
<p>The constructor creates the standard Bigtable Chubby paths:</p>
<ul>
<li><code>/bigtable/master-lock</code>: The master election lock.</li>
<li><code>/bigtable/root-tablet-location</code>: Stores where the root tablet lives.</li>
<li><code>/bigtable/servers</code>: A directory where each tablet server creates its lock file.</li>
<li><code>/bigtable/acls</code>: Access control lists.</li>
</ul>
<style>
   
  input.autofill-fix:-webkit-autofill,
  input.autofill-fix:-webkit-autofill:hover,
  input.autofill-fix:-webkit-autofill:focus,
  input.autofill-fix:-webkit-autofill:active {
    -webkit-text-fill-color: var(--primary2) !important;
    caret-color: var(--primary2) !important;
    -webkit-box-shadow: 0 0 0px 1000px var(--entry) inset !important;
    box-shadow: 0 0 0px 1000px var(--entry) inset !important;
    background-color: var(--entry) !important;
    transition: background-color 9999s ease-in-out 0s;
  }
</style>
<div style="max-width: 100%;
            margin: 2rem auto;
            padding: 1.5rem;
            border: 0.5px solid var(--border);
            border-radius: 12px;
            background: var(--entry)">
    <form action="https://buttondown.com/api/emails/embed-subscribe/jitesh117"
          target="_blank"
          method="post"
          class="embeddable-buttondown-form"
          style="text-align: left">
        <label for="bd-email"
               style="display: block;
                      margin-bottom: 0.5rem;
                      font-weight: 600;
                      font-size: 1rem;
                      color: var(--primary2)">Like what you are reading? Join the newsletter!</label>
        <input type="email"
               name="email"
               id="bd-email"
               class="autofill-fix"
               placeholder="you@example.com"
               required
               style="width: 100%;
                      padding: 0.65rem;
                      border: 1px solid #ccc;
                      border-radius: 8px;
                      margin-bottom: 1rem;
                      color: var(--primary2)" />
        <input type="submit"
               value="Subscribe"
               style="width: 100%;
                      padding: 0.75rem;
                      background: var(--primary);
                      color: var(--theme);
                      border: none;
                      border-radius: 8px;
                      font-weight: 600;
                      font-size: 1rem;
                      cursor: pointer" />
        <p style="font-size: 0.85rem; margin-top: 1rem; text-align: center"></p>
    </form>
</div>

<h2 id="7-bloom-filter">7. Bloom Filter<a hidden class="anchor" aria-hidden="true" href="#7-bloom-filter">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">BloomFilter</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">bits</span><span class="w">    </span><span class="p">[]</span><span class="kt">uint64</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">numBits</span><span class="w"> </span><span class="kt">uint</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">numHash</span><span class="w"> </span><span class="kt">uint</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Okay, this one is my favorite. A Bloom filter may sound fancy but it does exactly one thing: it tells you whether something is definitely not in a set, or probably is. That asymmetry is surprisingly powerful.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">bf</span><span class="w"> </span><span class="o">*</span><span class="nx">BloomFilter</span><span class="p">)</span><span class="w"> </span><span class="nf">MightContain</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">bf</span><span class="p">.</span><span class="nx">numHash</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">pos</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">bf</span><span class="p">.</span><span class="nf">hash</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">bf</span><span class="p">.</span><span class="nx">bits</span><span class="p">[</span><span class="nx">pos</span><span class="o">/</span><span class="mi">64</span><span class="p">]</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">pos</span><span class="o">%</span><span class="mi">64</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>Why it matters for performance</strong>: Without Bloom filters, a read for a row that doesn&rsquo;t exist in a given SSTable would require loading and scanning that SSTable&rsquo;s index from disk. With a Bloom filter, the tablet server can skip the disk read entirely if <code>MightContain</code> returns false. For workloads with many &ldquo;point reads&rdquo; of non-existent keys, this can eliminate the majority of SSTable I/O.</p>
<p>The filter uses CRC32 hashing with a seed per hash function. The number of bits and hash functions is computed from the expected item count and desired false positive rate using the standard Bloom filter formulas.</p>
<h2 id="8-memtable-the-in-memory-write-buffer">8. Memtable: The In-Memory Write Buffer<a hidden class="anchor" aria-hidden="true" href="#8-memtable-the-in-memory-write-buffer">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Memtable</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">entries</span><span class="w"> </span><span class="p">[]</span><span class="nx">MemtableEntry</span><span class="w"> </span><span class="c1">// sorted slice of CellKey -&gt; Cell</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">size</span><span class="w">    </span><span class="kt">int64</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">frozen</span><span class="w">  </span><span class="kt">bool</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">seqNo</span><span class="w">   </span><span class="kt">int64</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The memtable is the first place every write lands. It is an <strong>in-memory sorted buffer</strong> maintained in <code>CellKey</code> order. When the memtable reaches the size threshold (<code>DefaultMemtableMaxSize</code>), it is frozen and flushed to GFS as an immutable SSTable. A new, empty memtable takes its place.</p>
<h3 id="sorted-insertion">Sorted Insertion<a hidden class="anchor" aria-hidden="true" href="#sorted-insertion">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">m</span><span class="w"> </span><span class="o">*</span><span class="nx">Memtable</span><span class="p">)</span><span class="w"> </span><span class="nf">Insert</span><span class="p">(</span><span class="nx">cell</span><span class="w"> </span><span class="o">*</span><span class="nx">Cell</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">idx</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">entries</span><span class="p">),</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nf">CompareCellKeys</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">entries</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">key</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">})</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Insert at idx, shifting right</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="p">.</span><span class="nx">entries</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">entries</span><span class="p">,</span><span class="w"> </span><span class="nx">MemtableEntry</span><span class="p">{})</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">copy</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">entries</span><span class="p">[</span><span class="nx">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span><span class="w"> </span><span class="nx">m</span><span class="p">.</span><span class="nx">entries</span><span class="p">[</span><span class="nx">idx</span><span class="p">:])</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="p">.</span><span class="nx">entries</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">entry</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Binary search (<code>sort.Search</code>) finds the insertion point in O(log n) time. The slice is then shifted to make room: O(n) in the worst case, but acceptable for in-memory operations. In a production system, a skip list or balanced BST (like a red-black tree) would give O(log n) insertion and avoid the copy. The paper mentions that the original Bigtable used a skip list.</p>
<h3 id="get-and-scan">Get and Scan<a hidden class="anchor" aria-hidden="true" href="#get-and-scan">#</a></h3>
<p><code>Get(row, col, maxVersions)</code> uses a binary search to find the starting position (using <code>LatestTimestamp</code> as a sentinel to land before all versions of the key) then walks forward collecting versions.</p>
<p><code>Scan(rng, families)</code> similarly seeks to <code>rng.Start</code> and walks forward, skipping cells in families not in the filter set.</p>
<h3 id="freeze">Freeze<a hidden class="anchor" aria-hidden="true" href="#freeze">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">m</span><span class="w"> </span><span class="o">*</span><span class="nx">Memtable</span><span class="p">)</span><span class="w"> </span><span class="nf">Freeze</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="p">.</span><span class="nx">frozen</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Freezing a memtable is a lightweight operation: it just sets a flag. After freezing, the memtable becomes read-only. Write attempts return an error. The frozen memtable is added to the <code>immutable</code> slice on the tablet and remains readable while it is being written to disk.</p>
<h3 id="iterator">Iterator<a hidden class="anchor" aria-hidden="true" href="#iterator">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">MemtableIterator</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="w">   </span><span class="o">*</span><span class="nx">Memtable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">idx</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The iterator provides a cursor over the sorted entries, used during SSTable creation (the writer walks the memtable in order to produce a sorted SSTable).</p>
<h2 id="9-commit-log-the-write-ahead-log">9. Commit Log: The Write-Ahead Log<a hidden class="anchor" aria-hidden="true" href="#9-commit-log-the-write-ahead-log">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">CommitLog</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">gfs</span><span class="w">     </span><span class="o">*</span><span class="nx">GFS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">path</span><span class="w">    </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">seqNo</span><span class="w">   </span><span class="kt">int64</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">encoder</span><span class="w"> </span><span class="o">*</span><span class="nx">json</span><span class="p">.</span><span class="nx">Encoder</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">file</span><span class="w">    </span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The commit log is the <strong>durability guarantee</strong> of the system. Before any mutation is applied to the memtable, it must be durably written to the commit log on GFS. If the tablet server crashes, the log can be replayed to reconstruct the memtable.</p>
<h3 id="one-log-per-server-not-per-tablet">One Log Per Server (Not Per Tablet)<a hidden class="anchor" aria-hidden="true" href="#one-log-per-server-not-per-tablet">#</a></h3>
<p>Here&rsquo;s a decision that seems weird at first: instead of each tablet keeping its own log, the entire server shares one. Sounds messy, right? Turns out it&rsquo;s actually smarter. This dramatically reduces the number of concurrent GFS writes (GFS writes are expensive). The tradeoff is that recovery becomes more complex: when a server fails and its tablets are reassigned to different servers, each new server must sort through the log to find entries relevant to its tablets.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cl</span><span class="w"> </span><span class="o">*</span><span class="nx">CommitLog</span><span class="p">)</span><span class="w"> </span><span class="nf">Append</span><span class="p">(</span><span class="nx">tabletID</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">cell</span><span class="w"> </span><span class="o">*</span><span class="nx">Cell</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">int64</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">cl</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="nx">cl</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">cl</span><span class="p">.</span><span class="nx">seqNo</span><span class="o">++</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">rec</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">LogRecord</span><span class="p">{</span><span class="nx">SeqNo</span><span class="p">:</span><span class="w"> </span><span class="nx">cl</span><span class="p">.</span><span class="nx">seqNo</span><span class="p">,</span><span class="w"> </span><span class="nx">TabletID</span><span class="p">:</span><span class="w"> </span><span class="nx">tabletID</span><span class="p">,</span><span class="w"> </span><span class="nx">Cell</span><span class="p">:</span><span class="w"> </span><span class="nx">cell</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">cl</span><span class="p">.</span><span class="nx">seqNo</span><span class="p">,</span><span class="w"> </span><span class="nx">cl</span><span class="p">.</span><span class="nx">encoder</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">rec</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Each record is tagged with its <code>tabletID</code> so that during recovery, a server can filter for only the tablets it owns.</p>
<h3 id="recovery">Recovery<a hidden class="anchor" aria-hidden="true" href="#recovery">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">cl</span><span class="w"> </span><span class="o">*</span><span class="nx">CommitLog</span><span class="p">)</span><span class="w"> </span><span class="nf">ReadFrom</span><span class="p">(</span><span class="nx">minSeq</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="p">([]</span><span class="o">*</span><span class="nx">LogRecord</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// JSON-decode all records from disk, filter by seqNo &gt;= minSeq</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>ReadFrom</code> replays the log from a given sequence number. <code>Tablet.Recover()</code> calls this and re-inserts the relevant cells into a fresh memtable. The <code>minSeq</code> parameter allows the system to skip log entries that were already flushed to SSTables before the crash.</p>
<h2 id="10-sstable-immutable-on-disk-storage">10. SSTable: Immutable On-Disk Storage<a hidden class="anchor" aria-hidden="true" href="#10-sstable-immutable-on-disk-storage">#</a></h2>
<p>Once the memtable is full and frozen, it needs to go somewhere permanent. That&rsquo;s where SSTables come in, immutable files that sit on GFS and never change once written. Immutability sounds like a constraint, but it&rsquo;s actually what makes everything else easier: caching, replication, concurrent reads, all of it.</p>
<h3 id="file-format">File Format<a hidden class="anchor" aria-hidden="true" href="#file-format">#</a></h3>
<p>The SSTable binary format consists of four sections:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[ Data Blocks ][ Index Block ][ Bloom Filter ][ Footer (20 bytes) ]
</span></span></code></pre></div><ul>
<li><strong>Data Blocks</strong>: Fixed-size blocks of JSON-encoded cells, sorted by <code>CellKey</code>. Each block is up to 64 KB.</li>
<li><strong>Index Block</strong>: A JSON-encoded array of <code>(blockOffset, firstKey)</code> pairs, one entry per data block. This allows binary search to find the block containing a target key.</li>
<li><strong>Bloom Filter</strong>: A JSON-encoded bloom filter covering all <code>(row, family, qualifier)</code> triples in the file.</li>
<li><strong>Footer</strong>: Two <code>int64</code> values (offsets to the index and bloom filter) and a magic number (<code>0xB16B00B5</code>) for validation.</li>
</ul>
<h3 id="sstablewriter">SSTableWriter<a hidden class="anchor" aria-hidden="true" href="#sstablewriter">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">SSTableWriter</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">buf</span><span class="w">          </span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">index</span><span class="w">        </span><span class="nx">SSTableIndex</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">bloom</span><span class="w">        </span><span class="o">*</span><span class="nx">BloomFilter</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">blockCells</span><span class="w">   </span><span class="p">[]</span><span class="o">*</span><span class="nx">Cell</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">maxBlockSize</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The writer accumulates cells in <code>blockCells</code>. When the block reaches <code>maxBlockSize</code>, <code>flushBlock()</code> is called:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">w</span><span class="w"> </span><span class="o">*</span><span class="nx">SSTableWriter</span><span class="p">)</span><span class="w"> </span><span class="nf">flushBlock</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">offset</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">int64</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">buf</span><span class="p">.</span><span class="nf">Len</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">w</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">BlockOffsets</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">BlockOffsets</span><span class="p">,</span><span class="w"> </span><span class="nx">offset</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">w</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">FirstKeys</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">index</span><span class="p">.</span><span class="nx">FirstKeys</span><span class="p">,</span><span class="w"> </span><span class="nx">w</span><span class="p">.</span><span class="nx">blockCells</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">Key</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">binary</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">w</span><span class="p">.</span><span class="nx">buf</span><span class="p">,</span><span class="w"> </span><span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">,</span><span class="w"> </span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">blockCells</span><span class="p">)))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">w</span><span class="p">.</span><span class="nx">blockCells</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">enc</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The first key of each block is saved in the index so that readers can binary-search the index to skip directly to the right block.</p>
<p><code>Finish()</code> flushes the last block, writes the index and bloom filter, writes the footer, then atomically writes the entire buffer to GFS.</p>
<h3 id="sstablereader">SSTableReader<a hidden class="anchor" aria-hidden="true" href="#sstablereader">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">SSTableReader</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">path</span><span class="w">   </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">gfs</span><span class="w">    </span><span class="o">*</span><span class="nx">GFS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">data</span><span class="w">   </span><span class="p">[]</span><span class="kt">byte</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">index</span><span class="w">  </span><span class="nx">SSTableIndex</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">bloom</span><span class="w">  </span><span class="o">*</span><span class="nx">BloomFilter</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">loaded</span><span class="w"> </span><span class="kt">bool</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The reader is lazy, it only loads data from GFS on the first access (<code>load()</code>). This avoids I/O for SSTables that are never read.</p>
<p><strong>Get path</strong>:</p>
<ol>
<li>Check bloom filter. If <code>MightContain</code> returns false, return immediately (no I/O).</li>
<li>Binary-search the index for the block likely containing the key.</li>
<li>Decode only that block from <code>data</code>.</li>
<li>Walk the decoded cells looking for matches.</li>
</ol>
<p><strong>Scan path</strong>: Walk all blocks in order, filtering by row range and column families.</p>
<h2 id="11-tablet-a-contiguous-row-range">11. Tablet: A Contiguous Row Range<a hidden class="anchor" aria-hidden="true" href="#11-tablet-a-contiguous-row-range">#</a></h2>
<p>A tablet is the fundamental unit of distribution and load balancing in Bigtable. Each tablet covers a contiguous range of rows <code>[StartKey, EndKey)</code> in one table.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Tablet</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">ID</span><span class="w">        </span><span class="nx">TabletID</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Schema</span><span class="w">    </span><span class="o">*</span><span class="nx">TableSchema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">state</span><span class="w">     </span><span class="nx">TabletState</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">memtable</span><span class="w">  </span><span class="o">*</span><span class="nx">Memtable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">immutable</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">Memtable</span><span class="w">       </span><span class="c1">// frozen, awaiting flush</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">sstables</span><span class="w">  </span><span class="p">[]</span><span class="o">*</span><span class="nx">SSTableReader</span><span class="w">  </span><span class="c1">// newest first</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">blockCache</span><span class="w"> </span><span class="o">*</span><span class="nx">BlockCache</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">scanCache</span><span class="w">  </span><span class="o">*</span><span class="nx">ScanCache</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">log</span><span class="w">       </span><span class="o">*</span><span class="nx">CommitLog</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">gfs</span><span class="w">       </span><span class="o">*</span><span class="nx">GFS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="the-merged-read-view">The Merged Read View<a hidden class="anchor" aria-hidden="true" href="#the-merged-read-view">#</a></h3>
<p>The key insight of the tablet&rsquo;s read path is that at any moment, data for a row may exist in:</p>
<ul>
<li>The active memtable (most recent writes)</li>
<li>Zero or more frozen (immutable) memtables (being flushed)</li>
<li>Zero or more SSTables on GFS (previously flushed data)</li>
</ul>
<p>A correct read must return the union of all these sources, sorted by timestamp descending:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">Tablet</span><span class="p">)</span><span class="w"> </span><span class="nf">Get</span><span class="p">(</span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="nx">Column</span><span class="p">,</span><span class="w"> </span><span class="nx">maxVersions</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">([]</span><span class="o">*</span><span class="nx">Cell</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">allCells</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">allCells</span><span class="p">,</span><span class="w"> </span><span class="nx">mem</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="nx">maxVersions</span><span class="p">)</span><span class="o">...</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">im</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">immutable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">allCells</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">allCells</span><span class="p">,</span><span class="w"> </span><span class="nx">im</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="nx">maxVersions</span><span class="p">)</span><span class="o">...</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">sst</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">sstables</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">cells</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">sst</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="nx">maxVersions</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">allCells</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">allCells</span><span class="p">,</span><span class="w"> </span><span class="nx">cells</span><span class="o">...</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nf">mergeCells</span><span class="p">(</span><span class="nx">allCells</span><span class="p">,</span><span class="w"> </span><span class="nx">maxVersions</span><span class="p">),</span><span class="w"> </span><span class="kc">nil</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="mergecells">mergeCells<a hidden class="anchor" aria-hidden="true" href="#mergecells">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="nf">mergeCells</span><span class="p">(</span><span class="nx">cells</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">Cell</span><span class="p">,</span><span class="w"> </span><span class="nx">maxVersions</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">Cell</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">sort</span><span class="p">.</span><span class="nf">Slice</span><span class="p">(</span><span class="nx">cells</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Walk in order, applying tombstones, enforcing version limits</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>mergeCells</code> handles three concerns:</p>
<ol>
<li><strong>Deduplication</strong>: The same key can appear in multiple sources; the memtable&rsquo;s version wins.</li>
<li><strong>Tombstones</strong>: If a <code>Deleted</code> cell is encountered, all subsequent versions of that <code>(row)</code>, <code>(row, family)</code>, or <code>(row, family, qualifier)</code> are suppressed.</li>
<li><strong>Version limits</strong>: Only the first <code>maxVersions</code> non-deleted cells per <code>(row, family, qualifier)</code> group are returned.</li>
</ol>
<h3 id="minor-compaction">Minor Compaction<a hidden class="anchor" aria-hidden="true" href="#minor-compaction">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">Tablet</span><span class="p">)</span><span class="w"> </span><span class="nf">MinorCompaction</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. Freeze active memtable, swap in a new empty one</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">t</span><span class="p">.</span><span class="nx">memtable</span><span class="p">.</span><span class="nf">Freeze</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">frozen</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">memtable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">t</span><span class="p">.</span><span class="nx">memtable</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nf">NewMemtable</span><span class="p">(</span><span class="nx">newSeq</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">t</span><span class="p">.</span><span class="nx">immutable</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">immutable</span><span class="p">,</span><span class="w"> </span><span class="nx">frozen</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 2. Write frozen memtable to a new SSTable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">writer</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">NewSSTableWriter</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">gfs</span><span class="p">,</span><span class="w"> </span><span class="nx">sstPath</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">frozen</span><span class="p">.</span><span class="nx">entries</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">writer</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">cell</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">writer</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 3. Register the new SSTable as the newest</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">t</span><span class="p">.</span><span class="nx">sstables</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">([]</span><span class="o">*</span><span class="nx">SSTableReader</span><span class="p">{</span><span class="nx">reader</span><span class="p">},</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">sstables</span><span class="o">...</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Minor compaction converts the frozen memtable into an SSTable. It is triggered automatically when the memtable exceeds <code>DefaultMemtableMaxSize</code>. The frozen memtable stays readable until the SSTable is confirmed written, ensuring no data is lost.</p>
<h3 id="major-compaction">Major Compaction<a hidden class="anchor" aria-hidden="true" href="#major-compaction">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">Tablet</span><span class="p">)</span><span class="w"> </span><span class="nf">MajorCompaction</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. Read all cells from all existing SSTables</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 2. Merge them (mergeCells removes tombstones permanently)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 3. Write a single new SSTable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 4. Replace all old SSTables with the new one</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Major compaction is triggered when more than <code>DefaultMajorCompactionThreshold</code> SSTables exist. It serves two purposes:</p>
<ul>
<li><strong>Reclaims storage</strong>: Tombstones are only permanently removed during major compaction. Until then, they must be carried through minor compactions.</li>
<li><strong>Improves read performance</strong>: Each additional SSTable is one more source the read path must check. Reducing to a single SSTable minimizes I/O.</li>
</ul>
<p>The <code>compacting</code> atomic flag prevents concurrent major compactions on the same tablet.</p>
<h3 id="tablet-split">Tablet Split<a hidden class="anchor" aria-hidden="true" href="#tablet-split">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">Tablet</span><span class="p">)</span><span class="w"> </span><span class="nf">Split</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">Tablet</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="nx">Tablet</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">midKey</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">RowKey</span><span class="p">(</span><span class="nx">entries</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">entries</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">].</span><span class="nx">key</span><span class="p">.</span><span class="nx">Row</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">leftID</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="nx">TabletID</span><span class="p">{</span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="nx">EndKey</span><span class="p">:</span><span class="w"> </span><span class="nx">midKey</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">rightID</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">TabletID</span><span class="p">{</span><span class="o">...</span><span class="p">,</span><span class="w"> </span><span class="nx">StartKey</span><span class="p">:</span><span class="w"> </span><span class="nx">midKey</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nf">NewTablet</span><span class="p">(</span><span class="nx">leftID</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">),</span><span class="w"> </span><span class="nf">NewTablet</span><span class="p">(</span><span class="nx">rightID</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">),</span><span class="w"> </span><span class="kc">nil</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>When a tablet grows too large (not wired up in this demo but structurally complete), it is split at the median key. The master is notified, which updates the METADATA table and reassigns one of the two new tablets. Splits are always initiated by the tablet server (which knows the data), while the master coordinates the resulting reassignment.</p>
<h3 id="tablet-states">Tablet States<a hidden class="anchor" aria-hidden="true" href="#tablet-states">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">TabletState</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">const</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">TabletLoading</span><span class="w">    </span><span class="nx">TabletState</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">iota</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">TabletServing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">TabletCompacting</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">TabletUnloading</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>State transitions prevent races: a tablet in <code>TabletCompacting</code> state rejects new compaction requests; one in <code>TabletUnloading</code> is being prepared for transfer to another server.</p>
<h2 id="12-caches-block-cache-and-scan-cache">12. Caches: Block Cache and Scan Cache<a hidden class="anchor" aria-hidden="true" href="#12-caches-block-cache-and-scan-cache">#</a></h2>
<p>Two reads of the same row shouldn&rsquo;t cost the same as two reads of completely different rows. That&rsquo;s the whole motivation for caching here.
Both caches use a simple FIFO eviction policy (a production system would use LRU):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">BlockCache</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">data</span><span class="w">    </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="o">*</span><span class="nx">Cell</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">order</span><span class="w">   </span><span class="p">[]</span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">maxSize</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">ScanCache</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">data</span><span class="w">    </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="o">*</span><span class="nx">Cell</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">order</span><span class="w">   </span><span class="p">[]</span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">maxSize</span><span class="w"> </span><span class="kt">int</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="block-cache">Block Cache<a hidden class="anchor" aria-hidden="true" href="#block-cache">#</a></h3>
<p>The <strong>block cache</strong> stores decoded SSTable blocks. Without it, reading the same block twice (e.g., two reads of rows that fall in the same SSTable block) would require two disk reads and two JSON decodes. The block cache is especially valuable for hot row ranges.</p>
<h3 id="scan-cache">Scan Cache<a hidden class="anchor" aria-hidden="true" href="#scan-cache">#</a></h3>
<p>The <strong>scan cache</strong> stores the final merged results of <code>Get</code> calls, keyed by <code>&quot;get:{row}:{col}&quot;</code>. This is a higher-level cache: if the same <code>(row, column)</code> is read multiple times without any intervening writes, the second read is served directly from the cache without touching the memtable or any SSTable.</p>
<p>The scan cache is <strong>invalidated</strong> after writes (to ensure read-your-writes consistency) and after minor compactions (because the memtable contents changed). The <code>Clear()</code> method wipes the entire scan cache when a compaction completes.</p>
<h2 id="13-tablet-server">13. Tablet Server<a hidden class="anchor" aria-hidden="true" href="#13-tablet-server">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">TabletServer</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">ID</span><span class="w">        </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">chubby</span><span class="w">    </span><span class="o">*</span><span class="nx">Chubby</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">session</span><span class="w">   </span><span class="o">*</span><span class="nx">ChubbySession</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">lockPath</span><span class="w">  </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">gfs</span><span class="w">       </span><span class="o">*</span><span class="nx">GFS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">tablets</span><span class="w">   </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Tablet</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">commitLog</span><span class="w"> </span><span class="o">*</span><span class="nx">CommitLog</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">schemas</span><span class="w">   </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">TableSchema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The tablet server is the workhorse of the system. It holds a set of tablets, receives direct read/write requests from clients, and manages background compaction.</p>
<h3 id="startup-and-liveness">Startup and Liveness<a hidden class="anchor" aria-hidden="true" href="#startup-and-liveness">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">ts</span><span class="p">.</span><span class="nx">lockPath</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&#34;/bigtable/servers/&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nx">chubby</span><span class="p">.</span><span class="nf">TryLock</span><span class="p">(</span><span class="nx">ts</span><span class="p">.</span><span class="nx">lockPath</span><span class="p">,</span><span class="w"> </span><span class="nx">ts</span><span class="p">.</span><span class="nx">session</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>On startup, every tablet server creates a node in Chubby&rsquo;s <code>/bigtable/servers/</code> directory and acquires an exclusive lock on it. As long as this lock is held, the master knows the server is alive. The lock is maintained by the <code>heartbeatLoop</code> goroutine, which calls <code>RenewLease</code> every 2 seconds.</p>
<h3 id="background-goroutines">Background Goroutines<a hidden class="anchor" aria-hidden="true" href="#background-goroutines">#</a></h3>
<p>Three goroutines run continuously:</p>
<ol>
<li><strong><code>heartbeatLoop</code></strong>: Renews the Chubby session lease to maintain liveness.</li>
<li><strong><code>minorCompactionLoop</code></strong>: Polls all tablets for pending flush requests (via the <code>minorFlushCh</code> channel) and calls <code>MinorCompaction()</code>.</li>
<li><strong><code>majorCompactionLoop</code></strong>: Polls all tablets for pending major compaction requests (via <code>majorCompactCh</code>) and calls <code>MajorCompaction()</code>.</li>
</ol>
<p>Using channels for triggering (rather than polling size directly) means compaction is triggered immediately when thresholds are crossed, while the background loops add no overhead when nothing needs to be done.</p>
<h3 id="the-write-path">The Write Path<a hidden class="anchor" aria-hidden="true" href="#the-write-path">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ts</span><span class="w"> </span><span class="o">*</span><span class="nx">TabletServer</span><span class="p">)</span><span class="w"> </span><span class="nf">Write</span><span class="p">(</span><span class="nx">tabletStr</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">mutations</span><span class="w"> </span><span class="p">[]</span><span class="nx">Mutation</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. Verify session (ACL check via Chubby)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">ts</span><span class="p">.</span><span class="nx">session</span><span class="p">.</span><span class="nf">IsValid</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">mutations</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">cell</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Cell</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 2. Write to commit log (WAL), MUST persist before memtable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">ts</span><span class="p">.</span><span class="nx">commitLog</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">tabletStr</span><span class="p">,</span><span class="w"> </span><span class="nx">cell</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 3. Insert into memtable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">t</span><span class="p">.</span><span class="nf">Apply</span><span class="p">(</span><span class="nx">cell</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 4. Invalidate scan cache for written rows</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The ordering is critical: the WAL write <strong>must</strong> complete before the memtable write. If the server crashes after the WAL write but before the memtable write, recovery will replay the WAL and reconstruct the memtable. If the crash happened before the WAL write, neither the WAL nor the memtable has the data, but the client never received an acknowledgment, so it will retry.</p>
<h3 id="the-read-path">The Read Path<a hidden class="anchor" aria-hidden="true" href="#the-read-path">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ts</span><span class="w"> </span><span class="o">*</span><span class="nx">TabletServer</span><span class="p">)</span><span class="w"> </span><span class="nf">Read</span><span class="p">(</span><span class="nx">tabletStr</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="nx">Column</span><span class="p">,</span><span class="w"> </span><span class="nx">maxVersions</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">([]</span><span class="o">*</span><span class="nx">Cell</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">t</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">ts</span><span class="p">.</span><span class="nf">getTablet</span><span class="p">(</span><span class="nx">tabletStr</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="nx">maxVersions</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Reads go directly to the tablet&rsquo;s <code>Get()</code> method, which implements the merged view described in the Tablet section. Clients communicate directly with tablet servers, the master is not involved in the read path at all.</p>
<h3 id="atomic-read-modify-write">Atomic Read-Modify-Write<a hidden class="anchor" aria-hidden="true" href="#atomic-read-modify-write">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">ts</span><span class="w"> </span><span class="o">*</span><span class="nx">TabletServer</span><span class="p">)</span><span class="w"> </span><span class="nf">ReadModifyWrite</span><span class="p">(</span><span class="nx">tabletStr</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">ops</span><span class="w"> </span><span class="p">[]</span><span class="nx">ReadModifyWrite</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">t</span><span class="p">.</span><span class="nx">memMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span><span class="w">  </span><span class="c1">// hold the tablet&#39;s write lock for atomicity</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nx">memMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">op</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">ops</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">existing</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">t</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">op</span><span class="p">.</span><span class="nx">Col</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Compute new value (increment or append)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Write to WAL and memtable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Atomicity is achieved by holding the tablet&rsquo;s memtable lock for the entire read-compute-write operation. This is a coarse-grained lock, but it&rsquo;s correct: no other write can interleave with this operation. The paper describes a similar atomic <code>CheckAndMutate</code> operation for conditional writes.</p>
<h2 id="14-master-server">14. Master Server<a hidden class="anchor" aria-hidden="true" href="#14-master-server">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Master</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">chubby</span><span class="w">      </span><span class="o">*</span><span class="nx">Chubby</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">servers</span><span class="w">     </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">TabletServer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">schemas</span><span class="w">     </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">TableSchema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">assignments</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">TabletAssignment</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">unassigned</span><span class="w">  </span><span class="p">[]</span><span class="nx">TabletID</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The master is kind of like a manager who does zero actual work but keeps the whole team from falling apart. It never touches your data directly , clients never talk to it for reads or writes, but without it, nobody would know where anything lives. These are the operation master does:</p>
<ol>
<li><strong>Tablet assignment</strong>: Tracking which tablet server owns which tablet.</li>
<li><strong>Server failure detection</strong>: Using Chubby watches to detect dead servers and reclaim their tablets.</li>
<li><strong>Load balancing</strong>: Moving tablets from overloaded servers to underloaded ones.</li>
<li><strong>Table creation</strong>: Creating schemas and initializing the first tablet.</li>
</ol>
<h3 id="master-election">Master Election<a hidden class="anchor" aria-hidden="true" href="#master-election">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">m</span><span class="w"> </span><span class="o">*</span><span class="nx">Master</span><span class="p">)</span><span class="w"> </span><span class="nf">Elect</span><span class="p">()</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">m</span><span class="p">.</span><span class="nx">chubby</span><span class="p">.</span><span class="nf">TryLock</span><span class="p">(</span><span class="s">&#34;/bigtable/master-lock&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">m</span><span class="p">.</span><span class="nx">session</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;another master is already running&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="p">.</span><span class="nx">isMaster</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>At most one master is active at any time, enforced by the Chubby lock. If the active master dies, the lock is released and a standby master can acquire it.</p>
<h3 id="server-monitoring">Server Monitoring<a hidden class="anchor" aria-hidden="true" href="#server-monitoring">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">m</span><span class="w"> </span><span class="o">*</span><span class="nx">Master</span><span class="p">)</span><span class="w"> </span><span class="nf">checkServerLiveness</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">id</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">m</span><span class="p">.</span><span class="nx">servers</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">lockPath</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&#34;/bigtable/servers/&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">!</span><span class="nx">m</span><span class="p">.</span><span class="nx">chubby</span><span class="p">.</span><span class="nf">IsLockHeld</span><span class="p">(</span><span class="nx">lockPath</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// Server is dead: reclaim all its tablets</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="nx">tabletStr</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">m</span><span class="p">.</span><span class="nx">assignments</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="nx">a</span><span class="p">.</span><span class="nx">ServerID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">id</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nx">m</span><span class="p">.</span><span class="nx">unassigned</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">unassigned</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="p">.</span><span class="nx">TabletID</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">assignments</span><span class="p">,</span><span class="w"> </span><span class="nx">tabletStr</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">servers</span><span class="p">,</span><span class="w"> </span><span class="nx">id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="p">.</span><span class="nf">assignTablets</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Every 5 seconds, the master checks all known server lock paths in Chubby. If a lock is no longer held (the server died or its lease expired), the master marks all of that server&rsquo;s tablets as unassigned and calls <code>assignTablets()</code> to redistribute them.</p>
<h3 id="tablet-assignment">Tablet Assignment<a hidden class="anchor" aria-hidden="true" href="#tablet-assignment">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">m</span><span class="w"> </span><span class="o">*</span><span class="nx">Master</span><span class="p">)</span><span class="w"> </span><span class="nf">assignTablets</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">tabletID</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">m</span><span class="p">.</span><span class="nx">unassigned</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Find server with minimum current tablet count</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Register schema on that server, call ts.LoadTablet()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Assignment uses a greedy minimum-load heuristic: always assign to the server with the fewest tablets. A production system would factor in disk usage, memory pressure, and I/O load.</p>
<h3 id="load-balancing">Load Balancing<a hidden class="anchor" aria-hidden="true" href="#load-balancing">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">m</span><span class="w"> </span><span class="o">*</span><span class="nx">Master</span><span class="p">)</span><span class="w"> </span><span class="nf">rebalance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Find most-loaded and least-loaded servers</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// If difference &gt; 1, move one tablet from max to min</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The rebalancer runs every 30 seconds and moves one tablet per cycle from the most-loaded server to the least-loaded. Moving tablets gracefully requires <code>UnloadTablet</code> (which flushes the memtable) followed by <code>LoadTablet</code> (which recovers from the log).</p>
<h3 id="table-creation">Table Creation<a hidden class="anchor" aria-hidden="true" href="#table-creation">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">m</span><span class="w"> </span><span class="o">*</span><span class="nx">Master</span><span class="p">)</span><span class="w"> </span><span class="nf">CreateTable</span><span class="p">(</span><span class="nx">schema</span><span class="w"> </span><span class="o">*</span><span class="nx">TableSchema</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="p">.</span><span class="nx">schemas</span><span class="p">[</span><span class="nx">schema</span><span class="p">.</span><span class="nx">Name</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">schema</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">initialTablet</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">TabletID</span><span class="p">{</span><span class="nx">Table</span><span class="p">:</span><span class="w"> </span><span class="nx">schema</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span><span class="w"> </span><span class="nx">StartKey</span><span class="p">:</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="nx">EndKey</span><span class="p">:</span><span class="w"> </span><span class="kc">nil</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="p">.</span><span class="nx">unassigned</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">unassigned</span><span class="p">,</span><span class="w"> </span><span class="nx">initialTablet</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">m</span><span class="p">.</span><span class="nf">assignTablets</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>A new table starts with exactly one tablet covering the entire row key space <code>[nil, nil)</code>. As data accumulates, tablets are split by the tablet servers. This is the standard &ldquo;start with one shard, split as you grow&rdquo; approach used by many distributed databases.</p>
<h2 id="15-tablet-location-hierarchy">15. Tablet Location Hierarchy<a hidden class="anchor" aria-hidden="true" href="#15-tablet-location-hierarchy">#</a></h2>
<p>Every read and write needs to find the right tablet server first. Do that naively and you&rsquo;re adding a network round trip to every single operation. Bigtable&rsquo;s solution is a three-level hierarchy that can locate any of ~34 billion tablets in just three hops, and in practice, usually zero, thanks to client-side caching.</p>
<p>Finding the right tablet server for a given <code>(table, row)</code> pair is a three-level lookup, a B+-tree-like hierarchy that can address up to ~2^34 tablets with just three network round trips.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Level 0: Chubby file at /bigtable/root-tablet-location
</span></span><span class="line"><span class="cl">         ‚îî‚îÄ‚îÄ Contains address of ROOT tablet
</span></span><span class="line"><span class="cl">Level 1: ROOT tablet (part of METADATA table, never split)
</span></span><span class="line"><span class="cl">         ‚îî‚îÄ‚îÄ Contains locations of all other METADATA tablets
</span></span><span class="line"><span class="cl">Level 2: METADATA tablets
</span></span><span class="line"><span class="cl">         ‚îî‚îÄ‚îÄ Contains locations of all user tablets
</span></span></code></pre></div><p>The client-side cache makes this hierarchy efficient in practice:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">TabletLocationCache</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">cache</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">TabletLocation</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">TabletLocation</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">ServerID</span><span class="w">  </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">TabletStr</span><span class="w"> </span><span class="kt">string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">ExpiresAt</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Cache entries have a 30-second TTL. On a cache hit, the client contacts the tablet server directly, zero overhead. On a miss or a stale entry (tablet moved), the client re-traverses the hierarchy.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Client</span><span class="p">)</span><span class="w"> </span><span class="nf">findTabletServer</span><span class="p">(</span><span class="nx">table</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">TabletServer</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">loc</span><span class="p">,</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">locCache</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">table</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">);</span><span class="w"> </span><span class="nx">ok</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">ts</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">master</span><span class="p">.</span><span class="nf">GetTabletServer</span><span class="p">(</span><span class="nx">loc</span><span class="p">.</span><span class="nx">TabletStr</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">ts</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="p">.</span><span class="nx">TabletStr</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nx">c</span><span class="p">.</span><span class="nx">locCache</span><span class="p">.</span><span class="nf">Invalidate</span><span class="p">(</span><span class="nx">table</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Re-lookup via METADATA hierarchy (simplified: ask master directly)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">ts</span><span class="p">,</span><span class="w"> </span><span class="nx">tabletStr</span><span class="p">,</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">master</span><span class="p">.</span><span class="nf">FindTablet</span><span class="p">(</span><span class="nx">table</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">c</span><span class="p">.</span><span class="nx">locCache</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">table</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">TabletLocation</span><span class="p">{</span><span class="nx">TabletStr</span><span class="p">:</span><span class="w"> </span><span class="nx">tabletStr</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">})</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">ts</span><span class="p">,</span><span class="w"> </span><span class="nx">tabletStr</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>The paper notes that the client library prefetches tablet locations to further reduce latency. Our implementation includes the cache invalidation path: when a write fails (suggesting the tablet moved), the cache entry is invalidated before retrying.</p>
<h2 id="16-client-library">16. Client Library<a hidden class="anchor" aria-hidden="true" href="#16-client-library">#</a></h2>
<p>The client library is the public API of Bigtable. It hides all the complexity of location lookup, retry logic, and mutation encoding behind a clean interface.</p>
<h3 id="put-get-delete">Put, Get, Delete<a hidden class="anchor" aria-hidden="true" href="#put-get-delete">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Client</span><span class="p">)</span><span class="w"> </span><span class="nf">Put</span><span class="p">(</span><span class="nx">table</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="nx">Column</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Client</span><span class="p">)</span><span class="w"> </span><span class="nf">Get</span><span class="p">(</span><span class="nx">table</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="nx">Column</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">Cell</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Client</span><span class="p">)</span><span class="w"> </span><span class="nf">Delete</span><span class="p">(</span><span class="nx">table</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="nx">Column</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w">
</span></span></span></code></pre></div><p>These are the basic CRUD operations. <code>Put</code> creates a <code>MutationSet</code>; <code>Delete</code> creates a <code>MutationDelete</code> (tombstone). <code>Get</code> calls <code>GetVersions</code> with <code>maxVersions=1</code> and returns the first result.</p>
<h3 id="getversions">GetVersions<a hidden class="anchor" aria-hidden="true" href="#getversions">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Client</span><span class="p">)</span><span class="w"> </span><span class="nf">GetVersions</span><span class="p">(</span><span class="nx">table</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="nx">Column</span><span class="p">,</span><span class="w"> </span><span class="nx">maxVersions</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">([]</span><span class="o">*</span><span class="nx">Cell</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>Returns up to <code>maxVersions</code> historical versions, newest first. This is a key differentiator from traditional databases, Bigtable natively supports historical reads without needing a separate audit log.</p>
<h3 id="scan">Scan<a hidden class="anchor" aria-hidden="true" href="#scan">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Client</span><span class="p">)</span><span class="w"> </span><span class="nf">Scan</span><span class="p">(</span><span class="nx">table</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">startRow</span><span class="p">,</span><span class="w"> </span><span class="nx">endRow</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">families</span><span class="w"> </span><span class="p">[]</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">maxVersions</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">([]</span><span class="o">*</span><span class="nx">Cell</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>Scans a row range. In a real multi-tablet deployment, the scan would need to contact multiple tablet servers as it crosses tablet boundaries. This implementation handles the common single-tablet case; the multi-tablet case would require iterating <code>FindTablet</code> as the scan progresses.</p>
<h3 id="batchwrite">BatchWrite<a hidden class="anchor" aria-hidden="true" href="#batchwrite">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Client</span><span class="p">)</span><span class="w"> </span><span class="nf">BatchWrite</span><span class="p">(</span><span class="nx">table</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">mutations</span><span class="w"> </span><span class="p">[]</span><span class="nx">Mutation</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w">
</span></span></span></code></pre></div><p>Applies multiple mutations to a single row in one call. Because Bigtable guarantees per-row atomicity, all mutations in a batch either all succeed or all fail. This is important for maintaining consistency within a row (e.g., updating multiple columns of a user record atomically).</p>
<h3 id="increment-and-append">Increment and Append<a hidden class="anchor" aria-hidden="true" href="#increment-and-append">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Client</span><span class="p">)</span><span class="w"> </span><span class="nf">Increment</span><span class="p">(</span><span class="nx">table</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="nx">Column</span><span class="p">,</span><span class="w"> </span><span class="nx">delta</span><span class="w"> </span><span class="kt">int64</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">Client</span><span class="p">)</span><span class="w"> </span><span class="nf">Append</span><span class="p">(</span><span class="nx">table</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="w"> </span><span class="nx">RowKey</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="w"> </span><span class="nx">Column</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w">
</span></span></span></code></pre></div><p>These are higher-level operations built on top of <code>ReadModifyWrite</code>. <code>Increment</code> reads the current integer value, adds <code>delta</code>, and writes back. <code>Append</code> reads the current byte slice and appends <code>data</code>. Both are atomic because <code>ReadModifyWrite</code> holds the tablet&rsquo;s write lock.</p>
<h2 id="17-cluster-bootstrap">17. Cluster Bootstrap<a hidden class="anchor" aria-hidden="true" href="#17-cluster-bootstrap">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span><span class="w"> </span><span class="nx">Cluster</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Chubby</span><span class="w">        </span><span class="o">*</span><span class="nx">Chubby</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">GFS</span><span class="w">           </span><span class="o">*</span><span class="nx">GFS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">Master</span><span class="w">        </span><span class="o">*</span><span class="nx">Master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">TabletServers</span><span class="w"> </span><span class="p">[]</span><span class="o">*</span><span class="nx">TabletServer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">func</span><span class="w"> </span><span class="nf">NewCluster</span><span class="p">(</span><span class="nx">numServers</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="nx">Cluster</span><span class="p">,</span><span class="w"> </span><span class="kt">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">gfs</span><span class="w">    </span><span class="o">:=</span><span class="w"> </span><span class="nf">NewGFS</span><span class="p">(</span><span class="nx">GFSBaseDir</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">chubby</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">NewChubby</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">master</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">NewMaster</span><span class="p">(</span><span class="nx">chubby</span><span class="p">,</span><span class="w"> </span><span class="nx">gfs</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">master</span><span class="p">.</span><span class="nf">Elect</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Start N tablet servers</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Register each with the master</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">master</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">cluster</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>NewCluster</code> is the top-level constructor that bootstraps the entire system. It wires together all components in the correct order:</p>
<ol>
<li><strong>GFS first</strong>: All other components need storage.</li>
<li><strong>Chubby next</strong>: Master election and server registration depend on it.</li>
<li><strong>Master election</strong>: The master acquires its Chubby lock before doing anything else.</li>
<li><strong>Tablet servers</strong>: Each opens a session, acquires its lock, and starts background goroutines.</li>
<li><strong>Master starts</strong>: Now that it has servers registered, the master begins monitoring and assignment loops.</li>
<li><strong>Root tablet location published</strong>: The Chubby node is updated so clients can begin resolving locations.</li>
</ol>
<p><code>Cluster.CreateTable</code> is a convenience method that creates a <code>TableSchema</code>, registers column families, and calls <code>Master.CreateTable</code>.</p>
<p><code>Cluster.Stop</code> gracefully shuts down all servers and the master, releasing locks in the process.</p>
<h1 id="18-the-demo">18. The Demo<a hidden class="anchor" aria-hidden="true" href="#18-the-demo">#</a></h1>
<p>Okay enough theory. Let&rsquo;s actually run the thing.</p>
<h2 id="step-12-cluster-boot-and-table-creation">Step 1‚Äì2: Cluster Boot and Table Creation<a hidden class="anchor" aria-hidden="true" href="#step-12-cluster-boot-and-table-creation">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">cluster</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">NewCluster</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nx">cluster</span><span class="p">.</span><span class="nf">CreateTable</span><span class="p">(</span><span class="s">&#34;webtable&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">&amp;</span><span class="nx">ColumnFamily</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;anchor&#34;</span><span class="p">,</span><span class="w">   </span><span class="nx">MaxVersions</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">&amp;</span><span class="nx">ColumnFamily</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;contents&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">MaxVersions</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="nx">Compression</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;zlib&#34;</span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">&amp;</span><span class="nx">ColumnFamily</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;language&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">MaxVersions</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>We boot a 3-server cluster and create a <code>webtable</code>, the same example Google uses in the paper, which is a nice full-circle moment. The table has three column families: <code>anchor</code> for link anchor text, <code>contents</code> for the actual page HTML, and <code>language</code>. Row keys are reversed domain names (<code>com.google</code>, <code>com.cnn.www</code>) so that pages from the same domain end up physically next to each other on disk. This significantly makes it faster.</p>
<h2 id="step-34-writes-and-reads">Step 3‚Äì4: Writes and Reads<a hidden class="anchor" aria-hidden="true" href="#step-34-writes-and-reads">#</a></h2>
<p>Nothing fancy here, just a basic put followed by a get to confirm the write path and read path actually talk to each other correctly. If this works, the plumbing is good.</p>
<h2 id="step-5-multi-version-reads">Step 5: Multi-Version Reads<a hidden class="anchor" aria-hidden="true" href="#step-5-multi-version-reads">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">PutWithTimestamp</span><span class="p">(</span><span class="s">&#34;webtable&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">t0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">PutWithTimestamp</span><span class="p">(</span><span class="s">&#34;webtable&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">t1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">PutWithTimestamp</span><span class="p">(</span><span class="s">&#34;webtable&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">t2</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nx">versions</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">client</span><span class="p">.</span><span class="nf">GetVersions</span><span class="p">(</span><span class="s">&#34;webtable&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>This is one of my favorite parts of Bigtable. We write the same cell three times with different timestamps, then ask for all three versions back. They come out newest-first. This is exactly how the web crawl use case works in production, every time Google re-crawls a page, it doesn&rsquo;t overwrite the old content, it just writes a new version. You can always go back and ask &ldquo;what did this page look like six months ago?&rdquo;</p>
<h2 id="step-6-range-scan">Step 6: Range Scan<a hidden class="anchor" aria-hidden="true" href="#step-6-range-scan">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">cells</span><span class="p">,</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">client</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="s">&#34;webtable&#34;</span><span class="p">,</span><span class="w"> </span><span class="nf">RowKey</span><span class="p">(</span><span class="s">&#34;com.a&#34;</span><span class="p">),</span><span class="w"> </span><span class="nf">RowKey</span><span class="p">(</span><span class="s">&#34;com.z&#34;</span><span class="p">),</span><span class="w"> </span><span class="kc">nil</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>One line, but a lot happening under the hood. This scans every row between <code>com.a</code> and <code>com.z</code>. which, because of our reversed domain name trick, means every <code>.com</code> domain. The lexicographic ordering does all the heavy lifting here; this is not filtering per se, just exploiting how the data is laid out.</p>
<h2 id="step-78-atomic-counter-and-append">Step 7‚Äì8: Atomic Counter and Append<a hidden class="anchor" aria-hidden="true" href="#step-78-atomic-counter-and-append">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">Increment</span><span class="p">(</span><span class="s">&#34;usertable&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">userRow</span><span class="p">,</span><span class="w"> </span><span class="nx">counterCol</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">// 5 times</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="s">&#34;usertable&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">userRow</span><span class="p">,</span><span class="w"> </span><span class="nx">logCol</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;|search&#34;</span><span class="p">))</span><span class="w">
</span></span></span></code></pre></div><p>Both of these go through <code>ReadModifyWrite</code>, which holds the tablet&rsquo;s write lock for the entire read-compute-write cycle. That&rsquo;s what makes them atomic. <code>Increment</code> is exactly what you&rsquo;d use for page view counts. <code>Append</code> is perfect for activity streams, every action just gets tacked onto the end of a log column.</p>
<h2 id="step-9-deletion">Step 9: Deletion<a hidden class="anchor" aria-hidden="true" href="#step-9-deletion">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="s">&#34;webtable&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>Looks simple, but this doesn&rsquo;t actually delete anything yet. It writes a tombstone, a marker that says &ldquo;this cell is gone.&rdquo; The data physically disappears only when the next major compaction rolls around and merges everything together. Until then, the read path just sees the tombstone and skips over the old versions. It&rsquo;s a bit like marking an email as deleted without emptying the trash.</p>
<h2 id="step-10-compaction-under-load">Step 10: Compaction Under Load<a hidden class="anchor" aria-hidden="true" href="#step-10-compaction-under-load">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">client</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="s">&#34;webtable&#34;</span><span class="p">,</span><span class="w"> </span><span class="nx">randomRow</span><span class="p">,</span><span class="w"> </span><span class="nx">col</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>We hammer the table with 1000 writes to push the memtable over its 4MB threshold and trigger the background minor compaction loop. After the sleep, peek inside <code>/tmp/bigtable_gfs/sstables/</code>, you&rsquo;ll actually see the SSTable files sitting on disk. That&rsquo;s real data, written by the system we just built.</p>
<h2 id="step-11-batch-write">Step 11: Batch Write<a hidden class="anchor" aria-hidden="true" href="#step-11-batch-write">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">server</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">tabletStr</span><span class="p">,</span><span class="w"> </span><span class="nx">row</span><span class="p">,</span><span class="w"> </span><span class="p">[]</span><span class="nx">Mutation</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="nx">Col</span><span class="p">:</span><span class="w"> </span><span class="nx">Column</span><span class="p">{</span><span class="s">&#34;profile&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;name&#34;</span><span class="p">},</span><span class="w">  </span><span class="nx">Value</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;Alice&#34;</span><span class="p">)},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="nx">Col</span><span class="p">:</span><span class="w"> </span><span class="nx">Column</span><span class="p">{</span><span class="s">&#34;profile&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;email&#34;</span><span class="p">},</span><span class="w"> </span><span class="nx">Value</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;alice@example.com&#34;</span><span class="p">)},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="nx">Col</span><span class="p">:</span><span class="w"> </span><span class="nx">Column</span><span class="p">{</span><span class="s">&#34;activity&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;pageviews&#34;</span><span class="p">},</span><span class="w"> </span><span class="nx">Value</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;0&#34;</span><span class="p">)},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">})</span><span class="w">
</span></span></span></code></pre></div><p>Three columns, one call, one atomic operation. Either all three land or none of them do. This is per-row atomicity in action, if you&rsquo;re creating a user record and the server dies halfway through, you won&rsquo;t end up with a row that has a name but no email address.</p>
<h2 id="19-data-flow-summary">19. Data Flow Summary<a hidden class="anchor" aria-hidden="true" href="#19-data-flow-summary">#</a></h2>
<p>Alright, let&rsquo;s tie it all together. Here&rsquo;s what actually happens under the hood when you do a single write, from your client call all the way to durable storage.</p>
<h3 id="how-the-write-operates">How the write operates<a hidden class="anchor" aria-hidden="true" href="#how-the-write-operates">#</a></h3>
<p>First, the client&rsquo;s write request must reach the correct tablet server and be durably persisted:
<div style="display: flex; justify-content: center">
  <pre class="mermaid">
sequenceDiagram
participant Client
participant Cache as TabletLocationCache
participant TS as TabletServer (ts-1)
participant Chubby
participant CommitLog
participant GFS

    Note over Client,GFS: Phase 1: Write Request & Durability

    Client->>TS: Put("webtable", "com.google", Column{"anchor","Google"}, "Google HQ")
    TS->>Cache: findTabletServer()
    Cache-->>TS: Cache hit ‚Üí ("ts-1", "webtable[nil,nil)")

    TS->>Chubby: Verify session (ACL check)
    Chubby-->>TS: OK

    TS->>CommitLog: Append(tabletID, cell)
    CommitLog->>GFS: JSON encode LogRecord ‚Üí /tmp/bigtable_gfs/logs/ts-1.log
    GFS-->>CommitLog: seqNo = 42
    CommitLog-->>TS: Ack (Write is durable)

</pre>
</div>



<style>
  .mermaid {
    max-width: 100%;
    width: 100%;
    height: auto;
    margin: 1em 0;
  }
</style>

Once durable, the write is applied to the in-memory structure:</p>
<div style="display: flex; justify-content: center">
  <pre class="mermaid">
sequenceDiagram
participant TS as TabletServer (ts-1)
participant Tablet
participant Memtable
participant Cache as ScanCache

    Note over TS,Cache: Phase 2: Apply to Memtable

    TS->>Tablet: Apply(cell)
    Tablet->>Memtable: Insert(cell)
    Memtable-->>Tablet: Binary search insert
    Tablet-->>TS: Current size = 1.2MB

    TS->>Cache: Invalidate("com.google:anchor:Google")
    Cache-->>TS: Cache entry removed

    Note over TS,Memtable: Memtable threshold: 4MB
    Note over TS,Memtable: Current: 1.2MB (no flush needed)

</pre>
</div>



<style>
  .mermaid {
    max-width: 100%;
    width: 100%;
    height: auto;
    margin: 1em 0;
  }
</style>

<p>When memtable exceeds 4MB, background goroutines handle persistence:
<div style="display: flex; justify-content: center">
  <pre class="mermaid">
sequenceDiagram
participant TS as TabletServer
participant Tablet
participant Memtable
participant MinorBG as MinorCompaction Goroutine
participant MajorBG as MajorCompaction Goroutine
participant GFS

Note over TS,GFS: Phase 3: Compaction (Triggered when memtable ‚â• 4MB)

alt Memtable size >= 4MB
TS->>MinorBG: Signal minorFlushCh
activate MinorBG

    MinorBG->>Tablet: MinorCompaction()
    MinorBG->>Memtable: Freeze current memtable
    MinorBG->>Tablet: Create new memtable

    MinorBG->>GFS: Write SSTable (Finish)
    GFS-->>MinorBG: SSTable written

    MinorBG->>Tablet: Register SSTableReader (newest first)
    Tablet-->>MinorBG: Total SSTables = 6

    alt len(sstables) >= 5
        MinorBG->>MajorBG: Signal majorCompactCh
        activate MajorBG
        MajorBG->>Tablet: MajorCompaction()
        Note over MajorBG,Tablet: Merge multiple SSTables<br/>to reduce read amplification
        deactivate MajorBG
    end

    deactivate MinorBG

end

</pre>
</div>



<style>
  .mermaid {
    max-width: 100%;
    width: 100%;
    height: auto;
    margin: 1em 0;
  }
</style>
</p>
<h3 id="and-a-read">And a read:<a hidden class="anchor" aria-hidden="true" href="#and-a-read">#</a></h3>
<p>Every read starts with locating the tablet and checking the query result cache:</p>
<div style="display: flex; justify-content: center">
  <pre class="mermaid">

sequenceDiagram
participant Client
participant TS as TabletServer (ts-1)
participant Cache as TabletLocationCache
participant Tablet
participant ScanCache

    Note over Client,ScanCache: Phase 1: Request Routing & L1 Cache

    Client->>TS: Get("webtable", "com.google", Column{"anchor","Google"})

    TS->>Cache: findTabletServer()
    Cache-->>TS: Cache hit ‚Üí "ts-1"

    TS->>Tablet: Read(row="com.google", column="anchor:Google")

    Tablet->>ScanCache: Lookup("com.google:anchor:Google")
    ScanCache-->>Tablet: Cache Miss

    Note over Tablet: ScanCache miss ‚Üí Must read from storage layers

</pre>
</div>



<style>
  .mermaid {
    max-width: 100%;
    width: 100%;
    height: auto;
    margin: 1em 0;
  }
</style>

<p>On cache miss, Bigtable reads from three storage layers <strong>in order of freshness</strong>:
<div style="display: flex; justify-content: center">
  <pre class="mermaid">
sequenceDiagram
participant Tablet
participant Memtable
participant ImmMem as Immutable Memtables
participant SSTable
participant Bloom
participant Block

    Note over Tablet,Block: Phase 2: Multi-Level Storage Read

    Note over Tablet: Level 1: Active Memtable
    Tablet->>Memtable: Get(key, maxVersions=1)
    Memtable-->>Tablet: [Cell{value="Google HQ", ts=1234567}]

    Note over Tablet: Level 2: Immutable Memtables (pending flush)
    loop For each immutable memtable
        Tablet->>ImmMem: Get(key)
        ImmMem-->>Tablet: [] (empty)
    end

    Note over Tablet: Level 3: SSTables (newest ‚Üí oldest)
    loop For each SSTable
        Tablet->>Bloom: MightContain("com.google\x00anchor\x00Google")
        Bloom-->>Tablet: true (possible match)

        Tablet->>SSTable: Binary search index
        SSTable-->>Tablet: block 0 @ offset 0

        Tablet->>Block: Decode block
        Block-->>Tablet: [Cell{value="Google HQ", ts=999}]
    end

    Note over Tablet: Results collected:<br/>Memtable: ts=1234567<br/>SSTable: ts=999

</pre>
</div>



<style>
  .mermaid {
    max-width: 100%;
    width: 100%;
    height: auto;
    margin: 1em 0;
  }
</style>
</p>
<p>Bigtable&rsquo;s multi-versioning requires merging results from all layers:</p>
<div style="display: flex; justify-content: center">
  <pre class="mermaid">
sequenceDiagram
participant Tablet
participant Merger
participant ScanCache
participant TS as TabletServer
participant Client

    Note over Tablet,Client: Phase 3: Version Reconciliation & Response

    Note over Tablet: Collected results:<br/>‚Ä¢ Memtable: ts=1234567<br/>‚Ä¢ SSTable: ts=999

    Tablet->>Merger: mergeCells(allResults, maxVersions=1)

    Note over Merger: 1. Sort by timestamp desc<br/>[1234567, 999]<br/><br/>2. Apply version limit<br/>Keep only latest (1234567)<br/><br/>3. Apply tombstone rules

    Merger-->>Tablet: [Cell{value="Google HQ", ts=1234567}]

    Note over Tablet: Update cache for future reads
    Tablet->>ScanCache: Store("com.google:anchor:Google", result)
    ScanCache-->>Tablet: Cached

    Tablet-->>TS: Cell{value="Google HQ", ts=1234567}
    TS-->>Client: Cell{value="Google HQ", ts=1234567}

</pre>
</div>



<style>
  .mermaid {
    max-width: 100%;
    width: 100%;
    height: auto;
    margin: 1em 0;
  }
</style>

<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>If you&rsquo;ve made it this far, here&rsquo;s a cheat sheet of everything we built and how it maps back to the paper. Turns out one Go file can do a lot.</p>
<table>
  <thead>
      <tr>
          <th>Paper Concept</th>
          <th>Implementation</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Sparse sorted map</td>
          <td><code>CellKey</code> ordering with <code>CompareCellKeys</code></td>
      </tr>
      <tr>
          <td>Column families</td>
          <td><code>ColumnFamily</code>, <code>TableSchema</code></td>
      </tr>
      <tr>
          <td>Multi-version storage</td>
          <td><code>Timestamp</code> in <code>CellKey</code>, <code>mergeCells</code></td>
      </tr>
      <tr>
          <td>GFS integration</td>
          <td>Simulated <code>GFS</code> struct</td>
      </tr>
      <tr>
          <td>Chubby integration</td>
          <td>Full <code>Chubby</code> with sessions, locks, watches</td>
      </tr>
      <tr>
          <td>Commit log (WAL)</td>
          <td><code>CommitLog</code> with sequence numbers and replay</td>
      </tr>
      <tr>
          <td>Memtable</td>
          <td>Sorted <code>[]MemtableEntry</code> with freeze/swap</td>
      </tr>
      <tr>
          <td>SSTable</td>
          <td>Block format with index and bloom filter</td>
      </tr>
      <tr>
          <td>Minor compaction</td>
          <td>Memtable ‚Üí SSTable flush</td>
      </tr>
      <tr>
          <td>Major compaction</td>
          <td>Multi-SSTable merge with tombstone elimination</td>
      </tr>
      <tr>
          <td>Tablet split</td>
          <td>Median-key split returning two new tablets</td>
      </tr>
      <tr>
          <td>Tablet server</td>
          <td>Background goroutines, merged read view, WAL</td>
      </tr>
      <tr>
          <td>Master server</td>
          <td>Election, assignment, failure detection, rebalancing</td>
      </tr>
      <tr>
          <td>Three-level location hierarchy</td>
          <td>Chubby ‚Üí METADATA ‚Üí user tablets</td>
      </tr>
      <tr>
          <td>Client-side caching</td>
          <td><code>TabletLocationCache</code> with TTL</td>
      </tr>
      <tr>
          <td>Per-row atomicity</td>
          <td>Single-call batch mutations</td>
      </tr>
      <tr>
          <td>Read-modify-write</td>
          <td>Atomic increment and append</td>
      </tr>
  </tbody>
</table>
<p>The major simplifications versus a production system are: using <code>encoding/json</code> instead of a binary format, using a local filesystem instead of real GFS, using a sorted slice instead of a skip list for the memtable, and omitting network RPC (everything runs in-process). But the architecture, data flow, and algorithms are faithful to the original paper.</p>
        
<div class="callout callout-info">
    <div class="callout-emoji"><div class="emoji">‚ÑπÔ∏è</div></div>
    <div class="callout-content">
        <div class="callout-text"><p>Similar blog posts:</p>
<ol>
<li><a href="https://jitesh117.github.io/blog/implementing-mapreduce-in-golang/">MapReduce implementation in Go</a></li>
<li><a href="https://jitesh117.github.io/blog/implementing-tail-at-scale-in-golang/">Tail at Scale implementation in Go</a></li>
</ol></div>
    </div>
</div>
<style>
   
  .callout {
    overflow-x: auto;
    margin: 1.5rem 0;
    display: flex;
    border-left: 4px solid;
    border-radius: 0.75rem;
    background-color: #f9fafb;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    padding: 1rem;
    align-items: flex-start;
  }

  [dir="rtl"] .callout {
    padding: 0.5rem 0 0.5rem 1rem;
  }

   
  .callout-emoji {
    padding-left: 0.75rem;
    padding-right: 0.5rem;
  }

  [dir="rtl"] .callout-emoji {
    padding-right: 0.75rem;
    padding-left: 0.5rem;
  }

   
  .emoji {
    user-select: none;
    font-size: 1.25rem;
    font-family: "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  }

   
  .icon-inline {
    display: inline-block;
    vertical-align: middle;
    height: 1.2em;
  }

   
  .callout-content {
    width: 100%;
    min-width: 0;
    line-height: 1.75;
  }

   
  .callout-text {
    margin-top: 1.5rem;
    line-height: 1.75;
  }

  .callout-text:first-child {
    margin-top: 0;
  }

  .callout-default {
    border-color: rgba(251, 146, 60, 0.3);
    background-color: rgba(251, 146, 60, 0.2);
    color: rgb(253, 186, 116);
  }

  .callout-info {
    border-color: #6b4c3b;
    background-color: rgba(251, 146, 60, 0.2);
    color: rgb(191, 219, 254);
  }

  .callout-warning {
    border-color: rgba(253, 224, 71, 0.3);
    background-color: rgba(161, 98, 7, 0.3);
    color: rgb(253, 224, 71);
  }

  .callout-error {
    border-color: rgba(254, 202, 202, 0.3);
    background-color: rgba(153, 27, 27, 0.3);
    color: rgb(254, 202, 202);
  }
</style>

<p>In the next blog in this <a href="https://jitesh117.github.io/tags/paper-implementation/">paper implementation</a> series, I&rsquo;ll implement the <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf">Google File System</a> paper. Maybe even integrate to this implementation. Stay tuned! Subscribe to the <a href="https://buttondown.com/jitesh117">newsletter</a> if you haven&rsquo;t yet.</p>


    </div>
    <footer class="post-footer">
        <ul class="post-tags">
            <li>
                <a href="http://localhost:1313/tags/golang/">Golang</a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/paper-implementation/">Paper Implementation</a>
            </li>
        </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank"
           rel="noopener noreferrer"
           aria-label="share I Built Google Bigtable in Go: One File, Zero Dependencies on x"
           href="https://x.com/intent/tweet/?text=I%20Built%20Google%20Bigtable%20in%20Go%3a%20One%20File%2c%20Zero%20Dependencies&amp;url=http%3a%2f%2flocalhost%3a1313%2farchive%2fold_posts%2fimplementing-google-bigtable-in-golang%2f&amp;hashtags=golang%2cpaperimplementation">
            <svg version="1.1"
                 viewBox="0 0 512 512"
                 xml:space="preserve"
                 height="30px"
                 width="30px"
                 fill="currentColor">
                <path d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank"
           rel="noopener noreferrer"
           aria-label="share I Built Google Bigtable in Go: One File, Zero Dependencies on linkedin"
           href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2farchive%2fold_posts%2fimplementing-google-bigtable-in-golang%2f&amp;title=I%20Built%20Google%20Bigtable%20in%20Go%3a%20One%20File%2c%20Zero%20Dependencies&amp;summary=I%20Built%20Google%20Bigtable%20in%20Go%3a%20One%20File%2c%20Zero%20Dependencies&amp;source=http%3a%2f%2flocalhost%3a1313%2farchive%2fold_posts%2fimplementing-google-bigtable-in-golang%2f">
            <svg version="1.1"
                 viewBox="0 0 512 512"
                 xml:space="preserve"
                 height="30px"
                 width="30px"
                 fill="currentColor">
                <path d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank"
           rel="noopener noreferrer"
           aria-label="share I Built Google Bigtable in Go: One File, Zero Dependencies on reddit"
           href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2farchive%2fold_posts%2fimplementing-google-bigtable-in-golang%2f&title=I%20Built%20Google%20Bigtable%20in%20Go%3a%20One%20File%2c%20Zero%20Dependencies">
            <svg version="1.1"
                 viewBox="0 0 512 512"
                 xml:space="preserve"
                 height="30px"
                 width="30px"
                 fill="currentColor">
                <path d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank"
           rel="noopener noreferrer"
           aria-label="share I Built Google Bigtable in Go: One File, Zero Dependencies on facebook"
           href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2farchive%2fold_posts%2fimplementing-google-bigtable-in-golang%2f">
            <svg version="1.1"
                 viewBox="0 0 512 512"
                 xml:space="preserve"
                 height="30px"
                 width="30px"
                 fill="currentColor">
                <path d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank"
           rel="noopener noreferrer"
           aria-label="share I Built Google Bigtable in Go: One File, Zero Dependencies on whatsapp"
           href="https://api.whatsapp.com/send?text=I%20Built%20Google%20Bigtable%20in%20Go%3a%20One%20File%2c%20Zero%20Dependencies%20-%20http%3a%2f%2flocalhost%3a1313%2farchive%2fold_posts%2fimplementing-google-bigtable-in-golang%2f">
            <svg version="1.1"
                 viewBox="0 0 512 512"
                 xml:space="preserve"
                 height="30px"
                 width="30px"
                 fill="currentColor">
                <path d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank"
           rel="noopener noreferrer"
           aria-label="share I Built Google Bigtable in Go: One File, Zero Dependencies on telegram"
           href="https://telegram.me/share/url?text=I%20Built%20Google%20Bigtable%20in%20Go%3a%20One%20File%2c%20Zero%20Dependencies&amp;url=http%3a%2f%2flocalhost%3a1313%2farchive%2fold_posts%2fimplementing-google-bigtable-in-golang%2f">
            <svg version="1.1"
                 xml:space="preserve"
                 viewBox="2 2 28 28"
                 height="30px"
                 width="30px"
                 fill="currentColor">
                <path d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank"
           rel="noopener noreferrer"
           aria-label="share I Built Google Bigtable in Go: One File, Zero Dependencies on ycombinator"
           href="https://news.ycombinator.com/submitlink?t=I%20Built%20Google%20Bigtable%20in%20Go%3a%20One%20File%2c%20Zero%20Dependencies&u=http%3a%2f%2flocalhost%3a1313%2farchive%2fold_posts%2fimplementing-google-bigtable-in-golang%2f">
            <svg version="1.1"
                 xml:space="preserve"
                 width="30px"
                 height="30px"
                 viewBox="0 0 512 512"
                 fill="currentColor"
                 xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

    </footer>
</article>
    </main>
    
<footer class="footer">
    
    <a href="http://localhost:1313/donate" class="donate-big">Liked my blog and want to support? Click this button to donate!</a>
    <style>
    .donate-big {
      display: block;
      width: 100%;
      text-align: center;
      padding: 1rem 1.25rem;
      background: var(--primary);
      color: var(--theme) !important;
      border-radius: 0.75rem;
      font-size: 1.05rem;
      font-weight: 600;
      text-decoration: none;
      margin-bottom: 1.5rem;

      transition: background 0.2s ease;
    }
    </style>
    
    
<style>
   
  input.autofill-fix:-webkit-autofill,
  input.autofill-fix:-webkit-autofill:hover,
  input.autofill-fix:-webkit-autofill:focus,
  input.autofill-fix:-webkit-autofill:active {
    -webkit-text-fill-color: var(--primary2) !important;
    caret-color: var(--primary2) !important;
    -webkit-box-shadow: 0 0 0px 1000px var(--entry) inset !important;
    box-shadow: 0 0 0px 1000px var(--entry) inset !important;
    background-color: var(--entry) !important;
    transition: background-color 9999s ease-in-out 0s;
  }
</style>
<div style="max-width: 100%;
            margin: 2rem auto;
            padding: 1.5rem;
            border: 0.5px solid var(--border);
            border-radius: 12px;
            background: var(--entry)">
    <form action="https://buttondown.com/api/emails/embed-subscribe/jitesh117"
          target="_blank"
          method="post"
          class="embeddable-buttondown-form"
          style="text-align: left">
        <label for="bd-email"
               style="display: block;
                      margin-bottom: 0.5rem;
                      font-weight: 600;
                      font-size: 1rem;
                      color: var(--primary2)">Join the newsletter!</label>
        <input type="email"
               name="email"
               id="bd-email"
               class="autofill-fix"
               placeholder="you@example.com"
               required
               style="width: 100%;
                      padding: 0.65rem;
                      border: 1px solid #ccc;
                      border-radius: 8px;
                      margin-bottom: 1rem;
                      color: var(--primary2)" />
        <input type="submit"
               value="Subscribe"
               style="width: 100%;
                      padding: 0.75rem;
                      background: var(--primary);
                      color: var(--theme);
                      border: none;
                      border-radius: 8px;
                      font-weight: 600;
                      font-size: 1rem;
                      cursor: pointer" />
        <p style="font-size: 0.85rem; margin-top: 1rem; text-align: center"></p>
    </form>
</div>


    <span>&copy; 2026 <a href="http://localhost:1313/">Uday Parmar</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/"
           rel="noopener"
           target="_blank">PaperMod</a>
    </span>
    <span>¬∑</span>
    <span>
        <a target="_blank" href="https://jitesh117.github.io/index.xml">RSS Feed</a>
    </span>
    <span>¬∑</span>
    <span>
        <a target="_blank" href="https://buymeacoffee.com/jitesh117">Support my writing!</a>
    </span>
</footer><style>
  @media (max-width: 768px) {
    #bmc-iframe {
      border-radius: 0 !important;
    }
  }
</style>
<script
  data-name="BMC-Widget"
  data-cfasync="false"
  src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js"
  data-id="jitesh117"
  data-description="Support me on Buy me a coffee!"
  data-message="Like what you're reading? You can donate to support my writing!"
  data-color="#FFDD00"
  data-position="Right"
  data-x_margin="18"
  data-y_margin="18"
></script>
<style>
   
  @media (max-width: 1500px) {
    #bmc-iframe {
      border-radius: 0 !important;
    }

     
    .graph-fab {
      position: fixed;
      bottom: 18px;
      left: 18px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background-color: var(--primary);
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s;
      border: 2px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(2px);
    }

    .graph-fab:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.35);
    }

    .graph-fab img {
      width: 30px;
      height: 30px;
      object-fit: contain;
      filter: brightness(1.1);
    }

    .graph-container {
      position: fixed;
      bottom: 85px;
      left: 18px;
      width: 350px;
      height: 350px;
      background-color: var(--code-bg);
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25);
      padding: 15px;
      z-index: 99;
      display: none;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .graph-container.active {
      display: block;
      animation: fadeIn 0.3s ease-in-out;
    }
  }

   
  @media (min-width: 1501px) {
    .graph-fab {
      display: none;  
    }

    .graph-container {
      position: fixed;
      top: 50%;
      left: calc(((100% - 700px) / 2) / 2);  
      transform: translateY(-50%) translateX(-50%);  
      width: 350px;  
      height: 350px;
      background-color: var(--code-bg);
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25);
      padding: 15px;
      z-index: 99;
      display: block;  
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
  }

   
  .graph-container svg {
    display: block;
    margin: 0 auto;
    width: 100% !important;
    height: calc(100% - 40px) !important;
  }

  .graph-container svg g {
     
     
  }

  .graph-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 5px 0;
    margin-bottom: 5px;
    border-bottom: 1px solid rgba(125, 125, 125, 0.2);
  }

  .graph-title {
    font-size: 14px;
    color: var(--primary);
    padding: 0 10px;
    font-weight: 500;
  }

   
  .zoom-instructions {
    font-size: 12px;
    font-style: italic;
    opacity: 0.8;
    font-weight: normal;
    margin-left: 5px;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @media (max-width: 400px) {
    .graph-container {
      width: calc(100% - 36px);
    }
  }
</style>


<div id="graph-container" class="graph-container">
  <div class="graph-controls">
    <div class="graph-title">
      Topic Graph
      <span class="zoom-instructions">(Use scroll wheel to zoom)</span>
    </div>
  </div>
  <div class="component-graph-container" id="container-floating-graph">
  <div class="component-graph" id="floating-graph"></div>
</div>
<style>
  .component-graph-container {
      position: relative;
      width: 100%;
      margin: 20px 0;
      border-radius: 8px;
  }

  .component-graph {
      width: 100%;
        
      aspect-ratio: 1;
      border-radius: 16px;
      background-color: var(--code-bg, #f5f5f5);
      overflow: hidden;
  }

  .node-label {
      font-size: 10px;
      text-anchor: middle;
      pointer-events: none;
      font-family: sans-serif;
      fill: #333;
      user-select: none;
      opacity: 0;  
      transition: opacity 0.3s;
  }

  .node-label-background {
      fill: rgba(255, 255, 255, 0.8);
      rx: 3;
      ry: 3;
      pointer-events: none;
      opacity: 0;  
      transition: opacity 0.3s;
  }

  .tag-label {
      font-size: 12px;
      font-weight: bold;
      text-anchor: middle;
      pointer-events: none;
      font-family: sans-serif;
      fill: var(--primary);
      user-select: none;
  }

  .node-tooltip {
      position: absolute;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
      max-width: 200px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
  }
</style>
<script>
    (function () {
      
      let graphData = { nodes: [], links: [] };
      let simulation;
      let svg;
      let g; 
      let currentZoomScale = 1; 
      const zoomThreshold = 1.5; 
      const graphId = "floating-graph";
      const jsonPath = "\/index.json";
      const graphElement = document.getElementById(graphId);

      
      const colorPalette = [
        "#f28e2c",
        "#04ff00",
        "#b342f5",
        "#e6327a",
        "#edc949",
        "#76b7b2",
        "#af7aa1",
        "#9c755f",
        "#bab0ab",
        "#6b9ac4",
        "#d7a763",
        "#d37372",
        "#a4ccc9",
        "#8bb174",
        "#f1d78c",
      ];

      
      const tooltip = document.createElement("div");
      tooltip.className = "node-tooltip";
      document.getElementById(`container-${graphId}`).appendChild(tooltip);

      
      function initGraph() {
        
        const width = graphElement.clientWidth;
        const height = graphElement.clientHeight;

        
        if (graphElement.querySelector("svg")) {
          graphElement.querySelector("svg").remove();
        }

        
        svg = d3
          .select("#" + graphId)
          .append("svg")
          .attr("width", width)
          .attr("height", height)
          .attr("viewBox", `0 0 ${width} ${height}`);

        
        const zoom = d3
          .zoom()
          .scaleExtent([0.1, 10])
          .on("zoom", (event) => {
            g.attr("transform", event.transform);
            currentZoomScale = event.transform.k;

            
            updateLabelsVisibility(currentZoomScale);

            
            if (simulation) {
              adjustNodeSpacing(currentZoomScale);
            }
          });

        svg.call(zoom);

        
        g = svg.append("g");

        
        const tagConnections = {};
        graphData.nodes.forEach((node) => {
          if (node.isTag) {
            tagConnections[node.id] = 0;
          }
        });

        graphData.links.forEach((link) => {
          if (link.source.id) {
            if (tagConnections[link.source.id] !== undefined) {
              tagConnections[link.source.id]++;
            }
          } else if (tagConnections[link.source] !== undefined) {
            tagConnections[link.source]++;
          }
        });

        
        graphData.nodes.forEach((node) => {
          if (node.isTag) {
            const connectionCount = tagConnections[node.id] || 1;
            node.radius = Math.max(8, Math.min(14, 5 + connectionCount * 0.8));
            node.connections = connectionCount;
          } else {
            node.radius = 5;
          }
        });

        
        simulation = d3
          .forceSimulation(graphData.nodes)
          .force(
            "link",
            d3
              .forceLink(graphData.links)
              .id((d) => d.id)
              .distance((d) => {
                
                if (d.source.isTag) {
                  return 80 + d.source.connections * 2;
                }
                return 50;
              }),
          )
          .force(
            "charge",
            d3.forceManyBody().strength((d) => (d.isTag ? -300 : -50)),
          )
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force(
            "collision",
            d3.forceCollide().radius((d) => d.radius * 1.5),
          )
          .force("x", d3.forceX(width / 2).strength(0.1))
          .force("y", d3.forceY(height / 2).strength(0.1));

        
        const link = g
          .append("g")
          .attr("class", "links")
          .selectAll("line")
          .data(graphData.links)
          .enter()
          .append("line")
          .attr("stroke", "#888888") 
          .attr("stroke-opacity", 0.6)
          .attr("stroke-width", 1)
          .attr("data-source", (d) => d.source.id || d.source)
          .attr("data-target", (d) => d.target.id || d.target)
          .style("transition", "opacity 0.3s, stroke 0.3s, stroke-width 0.3s"); 

        
        const nodeGroup = g
          .append("g")
          .attr("class", "nodes")
          .selectAll("g")
          .data(graphData.nodes)
          .enter()
          .append("g")
          .attr("data-id", (d) => d.id)
          .style("cursor", "pointer")
          .call(drag(simulation))
          .on("click", (event, d) => {
            
            handleNodeClick(d);

            
            if (!d.isTag && (d.link || d.permalink)) {
              window.open(d.link || d.permalink, "_blank");
            } else if (d.isTag) {
                  
                  const tagName = d.title.replace(/\s+/g, "-");
                  const tagPermalink = 
                    "http://localhost:1313/tags/" + tagName.toLowerCase()
                  ;
                  window.open(tagPermalink, "_blank");
                }
          })
          .on("mouseover", (event, d) => {
            
            const tooltipText = d.isTag
              ? `Tag: ${d.title} (${d.connections} posts)`
              : d.title;
            showTooltip(tooltipText, event.pageX, event.pageY);
            highlightConnections(d);
          })
          .on("mousemove", (event) => {
            
            updateTooltipPosition(event.pageX, event.pageY);
          })
          .on("mouseout", () => {
            
            hideTooltip();
            resetHighlighting();
          });

        
        nodeGroup
          .append("circle")
          .attr("r", (d) => d.radius)
          .attr("fill", (d) => {
            if (d.isTag) {
              return colorPalette[d.colorIndex];
            }
            return "#ffffff";
          })
          .attr("stroke", (d) => (d.isTag ? "#333333" : "#888888"))
          .attr("stroke-width", (d) => (d.isTag ? 1.5 : 1))
          .style("transition", "opacity 0.3s, fill 0.3s, stroke-width 0.3s");

        
        nodeGroup
          .filter((d) => d.isTag)
          .append("text")
          .attr("class", "tag-label")
          .attr("dy", (d) => d.radius + 12) 
          .text((d) => d.title)
          .style("opacity", 0.85)
          .style("fill", (d) => {
            
            const color = d3.color(colorPalette[d.colorIndex]);
          })
          .each(function (d) {
            d.hasTagLabel = true; 
          });

        
        const labelGroups = nodeGroup
          .filter((d) => !d.hasTagLabel) 
          .append("g")
          .attr("class", "label-group");

        
        labelGroups
          .append("rect")
          .attr("class", "node-label-background")
          .attr("x", -40)
          .attr("y", (d) => d.radius + 2)
          .attr("width", 80) 
          .attr("height", 16)
          .style("opacity", 0);

        
        const labels = labelGroups
          .append("text")
          .attr("class", "node-label")
          .attr("dy", (d) => d.radius + 14) 
          .text((d) => d.title)
          .style("opacity", 0); 

        
        labels.each(function () {
          const bbox = this.getBBox();
          const parent = d3.select(this.parentNode);
          parent
            .select("rect")
            .attr("x", bbox.x - 2)
            .attr("width", bbox.width + 4);
        });

        
        function updateLabelsVisibility(scale) {
          
          nodeGroup
            .selectAll(".node-label")
            .style("opacity", scale >= zoomThreshold ? 1 : 0);
          nodeGroup
            .selectAll(".node-label-background")
            .style("opacity", scale >= zoomThreshold ? 0.8 : 0);

          
          nodeGroup
            .filter((d) => d.isTag)
            .selectAll(".tag-label")
            .style("opacity", 0.85);
        }

        
        function adjustNodeSpacing(scale) {
          
          const zoomFactor = Math.max(0, (scale - 1) * 1.2);

          
          const collisionRadius = (d) => {
            const baseRadius = d.radius * 1.5;
            return baseRadius * (1 + zoomFactor);
          };

          
          const linkDistance = (d) => {
            const baseDistance = d.source.isTag
              ? 80 + d.source.connections * 3
              : 60;
            return baseDistance * (1 + zoomFactor * 1.5);
          };

          
          const chargeStrength = (d) => {
            const baseCharge = d.isTag ? -300 : -50;
            return baseCharge * (1 + zoomFactor);
          };

          
          simulation
            .force("collision", d3.forceCollide().radius(collisionRadius))
            .force(
              "link",
              d3
                .forceLink(graphData.links)
                .id((d) => d.id)
                .distance(linkDistance),
            )
            .force("charge", d3.forceManyBody().strength(chargeStrength))
            .alpha(0.3) 
            .restart();
        }

        
        let isDragging = false;

        
        function handleNodeClick(d) {
          
          nodeGroup
            .selectAll("circle")
            .attr("fill", (n) => {
              if (n.isTag) {
                return colorPalette[n.colorIndex];
              }
              return "#ffffff";
            })
            .attr("stroke-width", (n) => (n.isTag ? 1.5 : 1));

          link
            .attr("stroke", "#888888")
            .attr("stroke-width", 1)
            .attr("stroke-opacity", 0.6);

          
          nodeGroup
            .filter((n) => n.id === d.id)
            .select("circle")
            .attr("stroke-width", 2.5)
            .attr("stroke", "#000000");

          const connectedNodes = [];

          if (d.isTag) {
            
            link.each(function (l) {
              if (l.source.id === d.id || l.source === d.id) {
                
                d3.select(this)
                  .attr("stroke", colorPalette[d.colorIndex])
                  .attr("stroke-width", 2)
                  .attr("stroke-opacity", 1);
                connectedNodes.push(l.target.id || l.target);
              }
            });
          } else {
            
            const connectedTagColors = {};

            link.each(function (l) {
              if (l.target.id === d.id || l.target === d.id) {
                const sourceId = l.source.id || l.source;
                const tagNode = graphData.nodes.find((n) => n.id === sourceId);
                if (tagNode) {
                  const tagColor = colorPalette[tagNode.colorIndex];
                  connectedTagColors[sourceId] = tagColor;

                  
                  d3.select(this)
                    .attr("stroke", tagColor)
                    .attr("stroke-width", 2)
                    .attr("stroke-opacity", 1);

                  connectedNodes.push(sourceId);
                }
              }
            });
          }

          
          nodeGroup
            .filter((n) => connectedNodes.includes(n.id))
            .select("circle")
            .attr("stroke-width", 2)
            .attr("stroke", "#000000");
        }

        
        function highlightConnections(d) {
          if (isDragging) return; 

          
          nodeGroup.style("opacity", 0.4);
          link.style("opacity", 0.1);

          
          nodeGroup.filter((n) => n.id === d.id).style("opacity", 1);

          const connectedNodes = [];

          if (d.isTag) {
            
            link.each(function (l) {
              if (l.source.id === d.id || l.source === d.id) {
                
                d3.select(this)
                  .style("opacity", 1)
                  .attr("stroke", colorPalette[d.colorIndex])
                  .attr("stroke-width", 1.5);
                connectedNodes.push(l.target.id || l.target);
              }
            });
          } else {
            
            link.each(function (l) {
              if (l.target.id === d.id || l.target === d.id) {
                const sourceId = l.source.id || l.source;
                const tagNode = graphData.nodes.find((n) => n.id === sourceId);

                if (tagNode) {
                  
                  d3.select(this)
                    .style("opacity", 1)
                    .attr("stroke", colorPalette[tagNode.colorIndex])
                    .attr("stroke-width", 1.5);
                  connectedNodes.push(sourceId);
                }
              }
            });
          }

          
          nodeGroup
            .filter((n) => connectedNodes.includes(n.id))
            .style("opacity", 1);
        }

        
        function resetHighlighting() {
          if (isDragging) return; 
          nodeGroup.style("opacity", 1);
          link
            .style("opacity", 0.6)
            .attr("stroke", "#888888")
            .attr("stroke-width", 1);
        }

        
        simulation.on("tick", () => {
          link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);

          nodeGroup.attr("transform", (d) => `translate(${d.x},${d.y})`);
        });
      }

      
      function showTooltip(text, x, y) {
        tooltip.textContent = text;
        tooltip.style.opacity = "1";
        updateTooltipPosition(x, y);
      }

      function updateTooltipPosition(x, y) {
        const rect = graphElement.getBoundingClientRect();
        const offsetX = x - rect.left;
        const offsetY = y - rect.top;

        tooltip.style.left = `${offsetX + 15}px`;
        tooltip.style.top = `${offsetY - 10}px`;
      }

      function hideTooltip() {
        tooltip.style.opacity = "0";
      }

      
      function drag(simulation) {
        function dragstarted(event) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          event.subject.fx = event.subject.x;
          event.subject.fy = event.subject.y;
          isDragging = true;
        }

        function dragged(event) {
          event.subject.fx = event.x;
          event.subject.fy = event.y;
        }

        function dragended(event) {
          if (!event.active) simulation.alphaTarget(0);
          event.subject.fx = null;
          event.subject.fy = null;
          setTimeout(() => {
            isDragging = false;
          }, 100);
        }

        return d3
          .drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended);
      }

      
      function processHugoData(data) {
        const postNodes = data.map((post, index) => ({
          id: "post-" + index,
          title: post.title,
          permalink: post.permalink,
          link: post.link || post.permalink,
          tags: post.tags || [],
          isTag: false,
        }));

        
        const allTags = new Set();
        postNodes.forEach((post) => {
          if (post.tags && post.tags.length > 0) {
            post.tags.forEach((tag) => allTags.add(tag));
          }
        });

        
        const tagNodes = Array.from(allTags).map((tag) => ({
          id: "tag-" + tag.replace(/\s+/g, "-").toLowerCase(),
          title: tag,
          isTag: true,
          colorIndex: 0, 
        }));

        
        const links = [];
        postNodes.forEach((post) => {
          if (post.tags && post.tags.length > 0) {
            post.tags.forEach((tag) => {
              const tagId = "tag-" + tag.replace(/\s+/g, "-").toLowerCase();
              links.push({
                source: tagId,
                target: post.id,
                value: 1,
              });
            });
          }
        });

        
        const tagAdjacencyMap = createTagAdjacencyMap(tagNodes, links);

        
        applyGraphColoring(tagNodes, tagAdjacencyMap);

        
        const nodes = [...tagNodes, ...postNodes];

        return { nodes, links };
      }

      
      function createTagAdjacencyMap(tagNodes, links) {
        const tagIds = tagNodes.map((tag) => tag.id);
        const adjacencyMap = {};

        
        tagIds.forEach((tagId) => {
          adjacencyMap[tagId] = new Set();
        });

        
        const postToTagsMap = {};

        
        links.forEach((link) => {
          const sourceId = link.source.id || link.source;
          const targetId = link.target.id || link.target;

          
          if (sourceId.startsWith("tag-") && !targetId.startsWith("tag-")) {
            if (!postToTagsMap[targetId]) {
              postToTagsMap[targetId] = [];
            }
            postToTagsMap[targetId].push(sourceId);
          }
        });

        
        Object.values(postToTagsMap).forEach((connectedTags) => {
          if (connectedTags.length > 1) {
            
            for (let i = 0; i < connectedTags.length; i++) {
              for (let j = 0; j < connectedTags.length; j++) {
                if (i !== j) {
                  adjacencyMap[connectedTags[i]].add(connectedTags[j]);
                }
              }
            }
          }
        });

        return adjacencyMap;
      }

      
      function applyGraphColoring(tagNodes, adjacencyMap) {
        
        const sortedTags = [...tagNodes].sort((a, b) => {
          const degreeA = adjacencyMap[a.id] ? adjacencyMap[a.id].size : 0;
          const degreeB = adjacencyMap[b.id] ? adjacencyMap[b.id].size : 0;
          return degreeB - degreeA; 
        });

        
        sortedTags.forEach((tagNode) => {
          const usedColors = new Set();

          
          if (adjacencyMap[tagNode.id]) {
            adjacencyMap[tagNode.id].forEach((adjacentTagId) => {
              
              const adjacentTag = tagNodes.find((t) => t.id === adjacentTagId);
              if (adjacentTag && adjacentTag.colorIndex !== undefined) {
                usedColors.add(adjacentTag.colorIndex);
              }
            });
          }

          
          let colorIndex = 0;
          while (usedColors.has(colorIndex)) {
            colorIndex++;
          }
          tagNode.colorIndex = colorIndex % colorPalette.length;
        });
      }

      
      function loadGraphData() {
  const jsonPath = "\/index.json";
  fetch(jsonPath)
          .then((response) => {
            if (!response.ok) {
              throw new Error("Network response was not ok");
            }
            return response.json();
          })
          .then((data) => {
            graphData = processHugoData(data);
            initGraph();
          })
          .catch((error) => {
            console.error("Error loading blog graph data:", error);
            graphElement.innerHTML =
              '<div style="padding: 20px; text-align: center;">Error loading blog graph data.</div>';
          });
      }

      
      window.addEventListener("resize", () => {
        if (simulation) {
          initGraph();
        }
      });

      
      function loadScript(url, callback) {
        if (typeof d3 !== "undefined") {
          callback();
          return;
        }

        const script = document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        script.onload = callback;
        document.head.appendChild(script);
      }

      
      loadScript(
        "https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js",
        loadGraphData,
      );
    })();
</script>

</div>

<div id="graph-fab" class="graph-fab">
  <img src="/images/graph_icon.png" alt="Graph" />
</div>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const fab = document.getElementById("graph-fab");
    const container = document.getElementById("graph-container");
    let graphInitialized = false;
    const isMobile = window.innerWidth <= 1500;

    
    if (!isMobile) {
      setTimeout(function () {
        window.dispatchEvent(new Event("resize"));
        graphInitialized = true;
      }, 500);
    }

    if (fab) {
      fab.addEventListener("click", function () {
        container.classList.toggle("active");

        
        if (!graphInitialized && container.classList.contains("active")) {
          setTimeout(function () {
            window.dispatchEvent(new Event("resize"));
            graphInitialized = true;
          }, 100);
        }
      });
    }

    
    document.addEventListener("click", function (event) {
      if (
        isMobile &&
        container &&
        !container.contains(event.target) &&
        fab &&
        !fab.contains(event.target) &&
        container.classList.contains("active")
      ) {
        container.classList.remove("active");
      }
    });
  });
</script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
